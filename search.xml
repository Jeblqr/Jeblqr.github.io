<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Dinic-当前弧优化 + 网络流算法时间复杂度纵向对比]]></title>
    <url>%2Fdetails%2F2018%2F08-26-DinicDQHYH.html</url>
    <content type="text"><![CDATA[之前的网络流（下）说过，Dinic有一个当前弧优化。那么今天就来说说“当前弧优化”。 怎么搞？当前弧优化也是很简单，只需要改两个地方。 当前因为是“当前”弧优化，所以我们先解决“当前”。 我们需要在统级函数中加上一个循环复制last到另一个数组里（我以head为例） 12345678910111213void NetworkFlows::dinic()&#123; mf=0; int lf=0; while (fdinic()) &#123; for (int i=1;i&lt;=n;i++) head[i]=last[i];//当前弧优化 while (lf=find(s,1&lt;&lt;26)) mf+=lf; &#125; &#125; 弧优化“当前”搞完了，再搞搞剩下的“弧优化”。 我们这个优化需要在深搜中搞。下面看代码注释。 123456789101112131415161718int NetworkFlows::find(int x,int lf)&#123; if (x==t) return lf; int rlf=0; for (int &amp;i=head[x];i;i=node[i].next)//注意&amp;i，这样我们才能改变head。 &#123; int y=node[i].y; if (node[i].v&amp;&amp;dist[y]==dist[x]+1) if (rlf=find(y,min(lf,node[i].v))) &#123; node[i].v-=rlf; node[i^1].v+=rlf; return rlf; &#125; &#125; return 0;&#125; 我们加了之后，我们就能记录优化（具体的只可意会不可言传，要靠理解（笑哭））。 源码好了，就讲这么多，下面是源代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#define Max 1100000using namespace std;class NetworkFlows&#123; struct Node &#123; int y,v,next; &#125;node[Max]; int dist[Max]; int len,last[Max],s,t,n,m,mf,head[Max]; int find(int x,int lf); void build(int x,int y,int v); public: void init(); void dinic(); bool fdinic(); void print();&#125;;void NetworkFlows::build(int x,int y,int v)&#123; len++; node[len].y=y,node[len].v=v,node[len].next=last[x],last[x]=len;&#125;void NetworkFlows::init()&#123; memset(node,0,sizeof node); int x,y,v; len=1; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for (int i=1;i&lt;=m;i++) cin&gt;&gt;x&gt;&gt;y&gt;&gt;v,build(x,y,v),build(y,x,0);&#125;bool NetworkFlows::fdinic()&#123; memset(dist,0x7f,sizeof dist); queue&lt;int&gt; que; que.push(s); dist[s]=0; while (que.size()) &#123; int x=que.front(); que.pop(); for (int i=last[x];i;i=node[i].next) &#123; int y=node[i].y; if (node[i].v&amp;&amp;dist[y]&gt;dist[x]+1) dist[y]=dist[x]+1,que.push(y); &#125; &#125; return dist[t]!=0x7f7f7f7f;&#125;int NetworkFlows::find(int x,int lf)&#123; if (x==t) return lf; int rlf=0; for (int &amp;i=head[x];i;i=node[i].next)//注意&amp;i，以便改变head[x]进行优化，等同于head[k]=i &#123; int y=node[i].y; if (node[i].v&amp;&amp;dist[y]==dist[x]+1) if (rlf=find(y,min(lf,node[i].v))) &#123; node[i].v-=rlf; node[i^1].v+=rlf; return rlf; &#125; &#125; return 0;&#125;void NetworkFlows::print()&#123; cout&lt;&lt;mf&lt;&lt;endl;&#125;void NetworkFlows::dinic()&#123; mf=0; int lf=0; while (fdinic()) &#123; /*for (int i=1;i&lt;=n;i++) head[i]=last[i];//当前弧优化*/ memcpy(head+1,last+1,n*4); while (lf=find(s,1&lt;&lt;26)) mf+=lf; &#125; &#125;NetworkFlows f;int main()&#123; f.init(); f.dinic(); f.print(); return 0;&#125; 效率？这里有两张洛谷模板题的截图，第一张没加优化，第二张加了。 再来一张EK的。]]></content>
      <tags>
        <tag>图论</tag>
        <tag>Dinic</tag>
        <tag>优化</tag>
        <tag>网络流</tag>
        <tag>效率对比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流：进阶篇]]></title>
    <url>%2Fdetails%2F2018%2F08-25-WanLuoLiujj.html</url>
    <content type="text"><![CDATA[惊了，竟然还有下 众说周知，EK算法的效率十分低下 (O(VE^2)),所以说，我们今天来讲讲另一种常用的而其更快的算法:Dinic 概念首先说一下Dinic算法是什么 Dinic算法（又称Dinitz算法）是一个在网络流中计算最大流的强多项式复杂度的算法，设想由以色列（前苏联）的计算机科学家Yefim (Chaim) A. Dinitz在1970年提出。 算法O(V^2E)的时间复杂度类似于Edmonds–Karp算法，其时间复杂度为O(VE^2)，Dinic算法与Edmonds–Karp算法的不同之处在于它每轮算法都选择最短的可行路径进行增广。 Dinic算法中采用高度标号（level graph）以及阻塞流（blocking flow）实现。(摘自维基百科，传送门) 蛤？和EK的时间复杂度类似？那我学了有什么用？ 其实，O(V^2E)的时间复杂度是Dinic的理论时间复杂度上限，在实际中几乎永远都跑不满，几乎只能用O(能过)来称之。所以说Dinic还是十分优益的(何况还有当前弧优化)。 先定义一下各种需要的东西 12345678910111213141516class NetworkFlows&#123; struct Node &#123; int y,v,next; &#125;node[Max]; //储存邻接表 int dist[Max];//储存分层的信息 int len,last[Max],s,t,n,m,mf;//分别是：指向最后一个邻接表的指针，指向最后一个同x（发出点）的指针数组，原点，汇点，点的个数，边的个数，最大流 int find(int x,int lf); void build(int x,int y,int v); public: void init(); void dinic(); bool fdinic(); void print();&#125;; 分层先看看普通的网络流的图长什么样子。 Dinic算法基于“分层图”的思想，那么我们再看看分了一次层的网络流的图长什么样子。 第一幅图是普通的网络流的图，而第二层是分了一次层的图。 我们可以把它想象成立起来的楼，从第0层（源点，以下叫它s）到最后一层（汇点，以下叫它t），每相邻两个楼层有楼梯。而我们的任务是不断把这张分层并且寻找最短的路径。 首先是如何分层的问题。 我们需要不断从s点向外拓展并且标上序号，那么我们应该第一时间可以想到广搜。换一个角度理解，就是把边权都为一的图跑SPFA（当然跑其他的也是ok的）。 12345678910111213141516171819bool NetworkFlows::fdinic()&#123; memset(dist,0x7f,sizeof dist); queue&lt;int&gt; que; dist[s]=0; que.push(s); while (que.size()) &#123; int x=que.front(); que.pop(); for (int i=last[x];i;i=node[i].next) &#123; int y=node[i].y; if (node[i].v&amp;&amp;dist[y]&gt;dist[x]+1)//node[i].v是判断该点是否还有流量可以走 dist[y]=dist[x]+1,que.push(y); &#125; &#125; return dist[t]!=0x7f7f7f7f;&#125; 寻找其次，我们要搞定如何寻找最短路。 我们已经分好层了，所以我们只需要考虑一条路径上的流量是多少，找出来并减掉它。 1234567891011121314151617int NetworkFlows::find(int x,int lf)//x是当前寻找的点，lf是这条路径上的最小流&#123; if (x==t)//如果找到就返回最小流 return lf; int rlf=0; for (int i=last[x];i;i=node[i].next)//寻找其他共x的边 &#123; int y=node[i].y; if (node[i].v&amp;&amp;dist[y]==dist[x]+1) if (rlf=find(y,min(lf,node[i].v)))//寻找下一个可以连接点，传min(lf,node[i].v)是为了让当前是最小的流 &#123; node[i].v-=rlf,node[i^1].v+=rlf;//减掉这条路径的最小流 return rlf; &#125; &#125; return 0;&#125; 统计那么我们怎么统计出来呢？ 我们还需要两层while循环，一层循环fdinic()以不断寻找分层图，一层find(s,1&lt;&gt;)不断去寻找当前分层图的最小流。 12345678void NetworkFlows::dinic()&#123; mf=0; int lowf=0; while (fdinic()) while (lowf=find(s,1&lt;&lt;26)) mf+=lowf;&#125; 源码好了，剩下的包括初始化和输入之类的应该不用讲了。那我们直接放代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#define Max 1100000using namespace std;class NetworkFlows&#123; struct Node &#123; int y,v,next; &#125;node[Max]; int dist[Max]; int len,last[Max],s,t,n,m,mf; int find(int x,int lf); void build(int x,int y,int v); bool fdinic(); public: void init(); void dinic(); void print();&#125;;void NetworkFlows::build(int x,int y,int v)&#123; len++; node[len].y=y,node[len].v=v,node[len].next=last[x],last[x]=len;&#125;void NetworkFlows::init()&#123; memset(node,0,sizeof node); int x,y,v; len=1; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for (int i=1;i&lt;=m;i++) cin&gt;&gt;x&gt;&gt;y&gt;&gt;v,build(x,y,v),build(y,x,0);&#125;bool NetworkFlows::fdinic()&#123; memset(dist,0x7f,sizeof dist); queue&lt;int&gt; que; dist[s]=0; que.push(s); while (que.size()) &#123; int x=que.front(); que.pop(); for (int i=last[x];i;i=node[i].next) &#123; int y=node[i].y; if (node[i].v&amp;&amp;dist[y]&gt;dist[x]+1) dist[y]=dist[x]+1,que.push(y); &#125; &#125; return dist[t]!=0x7f7f7f7f;&#125;int NetworkFlows::find(int x,int lf)&#123; if (x==t) return lf; int rlf=0; for (int i=last[x];i;i=node[i].next) &#123; int y=node[i].y; if (node[i].v&amp;&amp;dist[y]==dist[x]+1) if (rlf=find(y,min(lf,node[i].v))) &#123; node[i].v-=rlf,node[i^1].v+=rlf; return rlf; &#125; &#125; return 0;&#125;void NetworkFlows::print()&#123; cout&lt;&lt;mf&lt;&lt;endl;&#125;void NetworkFlows::dinic()&#123; mf=0; int lowf=0; while (fdinic()) while (lowf=find(s,1&lt;&lt;26)) mf+=lowf;&#125;NetworkFlows f;int main()&#123; f.init(); f.dinic(); f.print(); return 0;&#125; ##参考资料&amp;模板题 https://zh.wikipedia.org/wiki/Dinic%E7%AE%97%E6%B3%95 模板题点这里]]></content>
      <tags>
        <tag>图论</tag>
        <tag>Dinic</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆]]></title>
    <url>%2Fdetails%2F2018%2F08-24-Heap.html</url>
    <content type="text"><![CDATA[好，今天来讲堆。 priority_queue先讲一个十分偷懒的方法：STL中的容器：priority_queue（优先队列） 首先要先包含库,priority_queue包含于queue中： 1#include&lt;queue&gt; 先声明 12template &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue; 什么？看不懂？这里有一个简单版的~~ 1priority_queue&lt;typename/*你要定义的类型名*/,vector&lt;typename/*同上*/&gt; q; 默认是小根堆，如果想要大根堆怎么办?那就改成： 1priority_queue&lt;typename/*你要定义的类型名*/,vector&lt;typename/*同上*/,greater&lt;typename/*依然同上*/&gt; &gt; q; 啥？你自己写的结构体/类？那就重载&lt;号就行了！ 还有几个比较常用的操作： 1234q.push(x)//把x放入队中q.pop()//把队头删除出x=q.top()//取出队头的值（不会删掉）l=q.size()//获得队列中元素数量 堆好，讲正事：堆咋搞？ 概念我们以小根堆为例，首先要知道的是，堆是一棵完全二叉树，像这样 可以看出规律： A[i]&lt;=A[i2], A[i]&lt;=A[i2+1] 堆基本支持以下几种操作（其实我合并了一下，想了解完整的点这里： 123push(k)pop()top() 实现首先，我们先把该定义的给它定义了： 1int tree[1000000],len;//heap数组作为储存树用，len则指向最后一个元素 然后我们一个个实现这些操作。 push(k)我们先把k放入堆尾，不管它有没有序 1heap[++len]=k; 然后我们需要一些操作来维持它的性质。定义指针now和next分别指向堆尾和堆尾的父节点，也就是now/2 1int now=len,next=now/2; 然后呢，我们用一个while循环直到now到顶（==1）或者我们在中途打断它为止。 12345678while (now)&#123; if (tree[now] &lt; tree[next])//判断是否符合性质 swap(tree[now], tree[next]); else break;//如果没有交换，根据性质，该堆已经符合了性质，就可以退了 now = next, next = now / 2;//寻找下一个结点和其父节点&#125; push(k)就完成了。 pop()先把堆顶结点删掉。这个就有很多办法了。我选择把堆顶和堆尾交换然后len–。 12swap(tree[1], tree[len]);len--; 然后依然建立指针now和next，不过这次的now指向堆顶，next指向他的左子结点。 1int now = 1, next = now * 2; 还是使用while循环。 12345678910while (next &lt;= len)&#123; if (next &lt; len &amp;&amp; tree[next] &gt; tree[next + 1])//找出较小的子结点 next++; if (tree[now] &gt; tree[next])//注意大于号和小于号，push是从下至上而pop是从上至下所以应该反过来。 swap(tree[now], tree[next]); else//同上 break; now = next, next = now * 2;&#125; top()这个没什么好讲，直接把堆顶拿了就是了。 1return tree[1]; 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;iomanip&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;map&gt;#define Max 1100000using namespace std;//----------------------------class Heap&#123; int tree[Max]; int len; public: int push(int k); int pop(); int top(); void clear(); int size();&#125;;int Heap::push(int k)&#123; tree[++len] = k; int now = len, next = len / 2; while (now) &#123; if (tree[now] &lt; tree[next]) swap(tree[now], tree[next]); else break; now = next, next = now / 2; &#125; return k;&#125;int Heap::pop()&#123; swap(tree[1], tree[len]); len--; int now = 1, next = now * 2; while (next &lt;= len) &#123; if (next &lt; len &amp;&amp; tree[next] &gt; tree[next + 1]) next++; if (tree[now] &gt; tree[next]) swap(tree[now], tree[next]); else break; now = next, next = now * 2; &#125; return tree[len + 1];&#125;int Heap::top()&#123; return tree[1];&#125;void Heap::clear()&#123; memset(tree, 0, sizeof tree); len = 0;&#125;int Heap::size()&#123; return len;&#125;//----------------------------Heap heap;int main()&#123; return 0;&#125; 参考资料&amp;模板题https://zh.wikipedia.org/wiki/%E5%A0%86_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84) https://baike.baidu.com/item/最小堆/9139372?fromtitle=小根堆&amp;fromid=4633461&amp;fr=aladdin 模板题点这里]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>堆</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源点最短路径(上)]]></title>
    <url>%2Fdetails%2F2018%2F08-22-DanYuanDianZuiDuanLuJIng.html</url>
    <content type="text"><![CDATA[依然很可能没有下 最短路径？科科。说到最短路径，那么首先，最短路径是什么呢？很明显，是一个点到另一个点可行路径的最小权值和（废话） 上一幅图 我们设s=1，t=8，求的就是s~t中可行路径的权值和（要注意，边是双向的） 当然，最简单的办法是直接建立邻接矩阵，然后循环每个可行路径，最后找到最短路径。这就是Floyd算法。因为每个边都要拓展一次，所以说其时间复杂度是很大的（O(n^3)）。 邻接表所以说，我们这时应该换下思路。在Floyd中，我们使用“点”为标志存储，那我们可不可以使用“边”为标志存储呢？当然可以！邻接图！ 在下文中，我们把边的起点，终点和权值分别叫做x，y和d。我们使用一个结构体来储存边的y,d和上一条同x的边。 1234struct Node&#123; int y,d,next;&#125;node[1000000]; 为了储存上一条同x点边的下标，我们还需要一个数组last。同时，我们还需要一个变量len来储存当前边的下标以及一个数组ans来储存s-&gt;当前点的答案。 1int len,last[1000000],ans[1000000]; SPFA好，万事俱备。那么怎么求出最短路呢?先讲一个初级的算法：SPFA (shortest path faster algorithm)。这是Bellman-Ford算法的队列优化，SPFA只在中国大陆通用。发明者是个国人，这是论文。 队列优化是什么？当然是广度优先搜索啦！ 我们先将s点入队，并建立一个标记，然后进入一个循环，不断从队列中取出队头并拓展（专业点叫做“松弛”）。问题来了，怎么不断找到同端点的点呢？其实很简单，只需要一个循环就可以了。我们先从last数组中取出最后的一条边，再不断通过当前边的next找下一条边就可以了。 1234for (int i=last[kx];i;i=node[kx].next)//我们把队头的点叫做kx&#123; //.......&#125; 我们再把当前边的y叫做ky，把当前边的d叫做kd。如果ans[ky]&gt;ans[kx]+kd，那么就说明走这条边可能得到最优解，所以我们更新ans[ky]的值并判断有没有打上标记，没有的话，说明没有入队，那我们就把他入队。记得在循环的后面要把那个标记抹掉。 12345678910111213for (int i=last[kx];i;i=node[i].next)&#123; int ky=node[i].y; if (ans[ky]&gt;ans[kx]+node[i].d) &#123; ans[ky]=ans[kx]+node[i].d; if (!pd.count(ky)) &#123; pd.insert(ky); que.push(ky); &#125; &#125;&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;queue&gt;#define Max1 1000000#define Max2 1000000#define Max3 Max1using namespace std;//----------------------------class SPFA&#123; class Pc &#123; bool ps[Max3]; public: bool count(int k); void insert(int k); void clear(); bool erase(int k); &#125;; struct Node &#123; int x,y,d,next; &#125;; Node node[Max1]; int last[Max2],len,ans[Max1]; Pc pd; queue&lt;int&gt; que; void MakeLine(int x,int y,int d); public: void scan(int n); int calc(int x,int y);&#125;;bool SPFA::Pc::count(int k)&#123;return (ps[k]);&#125;void SPFA::Pc::insert(int k)&#123;ps[k]=1;&#125;void SPFA::Pc::clear()&#123;memset(ps,0,sizeof ps);&#125;bool SPFA::Pc::erase(int k)&#123;ps[k]=0;&#125;void SPFA::MakeLine(int x,int y,int d)&#123; len++; node[len].x=x,node[len].y=y,node[len].d=d,node[len].next=last[x]; last[x]=len;&#125;int SPFA::calc(int x,int y)&#123; memset(ans,0x7f,sizeof ans); ans[x]=0; while (que.size()) que.pop(); pd.clear(); que.push(x); pd.insert(x); while (!que.empty()) &#123; int kx=que.front(); que.pop(); pd.erase(kx); for (int i=last[kx];i;i=node[i].next) &#123; int ky=node[i].y; if (ans[ky]&gt;ans[kx]+node[i].d) &#123; ans[ky]=ans[kx]+node[i].d; if (!pd.count(ky)) &#123; pd.insert(ky); que.push(ky); &#125; &#125; &#125; &#125; return ans[y]==0x7f7f7f7f?-1:ans[y];&#125;void SPFA::scan(int n)&#123; int x,y,v; for (int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;v; MakeLine(x,y,v); MakeLine(y,x,v); &#125;&#125;//----------------------------SPFA spfa;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; spfa.scan(m); cout&lt;&lt;spfa.calc(1,n); return 0;&#125; 时间复杂度这个算法时间复杂度虽然还ok，但是稠密图是会下降为O(VE)。 话说平均复杂度竟然是通过实验得出的，太不靠谱了吧？ 参考资料https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%BF%AB%E9%80%9F%E7%AE%97%E6%B3%95 https://baike.baidu.com/item/SPFA%E7%AE%97%E6%B3%95/8297411?fromtitle=SPFA&amp;fromid=11018124&amp;fr=aladdin]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路径</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流：入门篇]]></title>
    <url>%2Fdetails%2F2018%2F08-04-WanLuoLiurm.html</url>
    <content type="text"><![CDATA[（也不知道会不会有进阶篇） Part1 最大流什么叫网络流 okok，我们先来讲一下什么叫网络流 这里有一幅图 每一个边都有一个流量，我们叫它V 把它想象成一个自来水厂和你家之间的供水线路，有一个原点s(自来水厂)和一个汇点t(你家)。问你家在一个单位时间内最大可以有多少水用。 很明显，水的多少取决于最小的边的流量。在这张图中，你家最多可以有7+4=13的水。 那么算法的关键就是如何找出最小的边并拓展。 EK 祭出大法：EK(Edmonds-Karp)算法！ 先看下定义。 定义&amp;实现1234567891011121314struct Node&#123; int y,v,next;&#125;node[Max];//记录边，y为尾，v为该边流量，next为下一条同首的边struct prev&#123; int x,i; &#125;pre[Max];//记录当前增广路的边，x为首，i为尾。bool pd[Max];//判断是否在队中int len,last[Max],s,t,n,m;//len是用于记录边的，last当前是以x为首的最后一条边。bool find();//寻找增广路void build(int x,int y,int v);//建边void init();//初始化int EK();//循环计数 该算法使用一个张扬而不做作的广搜，拓展所有以que.front()为开头的边(初始化时，s入队)，当判断它没有被记录时，记录。当当前拓展的边就是t时,返回1。当队列为空时，说明所有的边以及拓展完毕，没有找到t，就是没有从s-&gt;t的边，返回0； 123456789101112131415161718192021222324memset(pd,0,sizeof pd);memset(pre,0,sizeof pre);queue&lt;int&gt; que;que.push(s);pd[s]=1;while (!que.empty())&#123; int x=que.front(); que.pop(); for (int i=last[x];i;i=node[i].next)//寻找以x为首的边（或者说x可以拓展的边） &#123; int y=node[i].y; if (!pd[y]&amp;&amp;node[i].v)//如果当前边没有被记录过并且还有空间可以流水 &#123; pd[y]=1;//打上标记，表示被记录 pre[y].x=x;//记录边 pre[y].i=i;//同上 que.push(y);//入队 if (y==t) return 1; &#125; &#125; return 0;&#125; 再使用一个低调奢华有内涵的循环。当当前还存在增广路的话，循环遍历寻找增广路上最小的值，再循环遍历剪掉。此时，最大流加上当前的最小的值。 当广搜返回0时，说明没有增广路了，当前已累计最大流。 1234567891011int ans=0;while (find())&#123; int minn=1&lt;&lt;26; for (int i=t;i!=s;i=pre[i].x) minn=min(minn,node[pre[i].i].v); for (int i=t;i!=s;i=pre[i].x) node[pre[i].i].v-=minn,node[pre[i].i^1].v+=minn;//要注意，len要从一个奇数开始，这样把当前的编号^1就是其反向边的编号;我喜欢用1.你用其他的话你自己修改。 ans+=minn;&#125;return ans; 完整源码什么？你想要完整版？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#define Max 1100000using namespace std;class NetworkFlows&#123; struct Node &#123; int y,v,next; &#125;node[Max]; struct prev &#123; int x,i; &#125;pre[Max]; bool pd[Max]; int len,last[Max],s,t,n,m; bool find(); void build(int x,int y,int v); public: void init(); int EK();&#125;;void NetworkFlows::build(int x,int y,int v)&#123; len++; node[len].y=y,node[len].v=v,node[len].next=last[x],last[x]=len;&#125;void NetworkFlows::init()&#123; memset(node,0,sizeof node); int x,y,d; len=1; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for (int i=1;i&lt;=m;i++) cin&gt;&gt;x&gt;&gt;y&gt;&gt;d,build(x,y,d),build(y,x,0);&#125;bool NetworkFlows::find()&#123; memset(pd,0,sizeof pd); memset(pre,0,sizeof pre); queue&lt;int&gt; que; que.push(s); pd[s]=1; while (!que.empty()) &#123; int x=que.front(); que.pop(); for (int i=last[x];i;i=node[i].next) &#123; int y=node[i].y; if (!pd[y]&amp;&amp;node[i].v) &#123; pd[y]=1; pre[y].x=x; pre[y].i=i; que.push(y); if (y==t) return 1; &#125; &#125; &#125; return 0;&#125;int NetworkFlows::EK()&#123; int ans=0; while (find()) &#123; int minn=1&lt;&lt;26; for (int i=t;i!=s;i=pre[i].x) minn=min(minn,node[pre[i].i].v); for (int i=t;i!=s;i=pre[i].x) node[pre[i].i].v-=minn,node[pre[i].i^1].v+=minn; ans+=minn; &#125; return ans;&#125;NetworkFlows f;int main()&#123; f.init(); cout&lt;&lt;f.EK()&lt;&lt;endl; return 0;&#125; 注意咯！需要特别注意的是，要加上反向边！！！拓展到反向边时，要加上当前最小的值你问我为什么？我怎么知道！ (╯≥▽≤)╯~ ┴—┴ 咳咳，其实这样才可以有后悔的机会嘛。 Part2 最小费用最大流什么是“最小费用”先看一下最小费用是啥 我们在流量v的基础上又加了一个花费w，我们要求的是最大流中的最小花费 说到最小费用先想到什么呢？最短路！所以我们可以用一个最短路算法（也就是说把原来的广搜换成最短路并记录路径）（我喜欢用spfa毕竟我不会其他的）来求出一条s-&gt;t花费最小的边并累加费用和流量就ok了！ 要注意，我们要在加反向边且v为0的基础上，同时设反向边的w为-w，这样我们便有后悔的机会。 源码放出代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#define Max 1100000using namespace std;class NetworkFlows&#123; struct Node &#123; int y,v,w,next; &#125;node[Max]; struct prev &#123; int x,i; &#125;pre[Max]; bool pd[Max]; int spfa[Max]; int len,last[Max],s,t,n,m,mf,co;//co是花费 bool find(); void build(int x,int y,int v,int w); public: void init(); void EK(); void print();&#125;;void NetworkFlows::build(int x,int y,int v,int w)&#123; len++; node[len].y=y,node[len].v=v,node[len].w=w,node[len].next=last[x],last[x]=len;&#125;void NetworkFlows::init()&#123; memset(node,0,sizeof node); int x,y,v,w; len=1; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for (int i=1;i&lt;=m;i++) cin&gt;&gt;x&gt;&gt;y&gt;&gt;v&gt;&gt;w,build(x,y,v,w),build(y,x,0,-w);&#125;bool NetworkFlows::find()//spfa求最短路&#123; memset(pd,0,sizeof pd); memset(pre,0,sizeof pre); memset(spfa,0x3f,sizeof spfa); queue&lt;int&gt; que; que.push(s); pd[s]=1; spfa[s]=0; while (!que.empty()) &#123; int x=que.front(); que.pop(); pd[x]=0; for (int i=last[x];i;i=node[i].next) &#123; int y=node[i].y; if (spfa[y]&gt;spfa[x]+node[i].w&amp;&amp;node[i].v) &#123; spfa[y]=spfa[x]+node[i].w; pre[y].i=i,pre[y].x=x; if (!pd[y]) pd[y]=1,que.push(y); &#125; &#125; &#125; return spfa[t]!=0x3f3f3f3f;//是否有s-&gt;t的路径&#125;void NetworkFlows::print()&#123; cout&lt;&lt;mf&lt;&lt;' '&lt;&lt;co&lt;&lt;endl;&#125;void NetworkFlows::EK()&#123; mf=0,co=0; while (find()) &#123; int minn=1&lt;&lt;26; for (int i=t;i!=s;i=pre[i].x) minn=min(minn,node[pre[i].i].v); for (int i=t;i!=s;i=pre[i].x) node[pre[i].i].v-=minn,node[pre[i].i^1].v+=minn; mf+=minn; co+=minn*spfa[t]; &#125;&#125;NetworkFlows f;int main()&#123; f.init(); f.EK(); f.print(); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>EK</tag>
      </tags>
  </entry>
</search>
