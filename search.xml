<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Tarjan（有向图的强连通分量）]]></title>
    <url>%2Fdetails%2F2019%2F04-12-Tarjan1.html</url>
    <content type="text"><![CDATA[烂尾预定 Have you 听过 Tarjan？ 此算法以一个有向图作为输入，并按照所在的强连通分量给出其顶点集的一个划分。图中的每个节点只在一个强连通分量中出现，即使是在有些节点单独构成一个强连通分量的情况下（比如图中出现了树形结构或孤立节点）。算法的基本思想如下：任选一节点开始进行深度优先搜索（若深度优先搜索结束后仍有未访问的节点，则再从中任选一点再次进行）。搜索进程中已访问的节点不再访问。搜索树的若干子树构成了图的强连通分量。节点按照被访问的顺序存入堆栈中。从搜索树的子树返回至一个节点时，检查该节点是否是某一强连通分量的根节点（见下）并将其从堆栈中删除。如果某节点是强连通分量的根，则在它之前出堆栈且还不属于其他强连通分量的节点构成了该节点所在的强连通分量。(来自Wikipedia) 看不懂对不对？ 我也是 那我们一个一个来解决。 什么是强连通分量？ 强连通分量（英语：Strongly connected component）是图论中的概念。图论中，强连通图指每一个顶点皆可以经由该图上的边抵达其他的每一个点的有向图。意即对于此图上每一个点对$(Va,Vb)$ ，皆存在路径 $Va→Vb$ 以及 $Vb→Va$ 。强连通分量则是指一张有向图$G$的极大强连通子图$G’$。如果将每一个强连通分量缩成一个点，则原图$G$将会变成一张有向无环图。一张图被称为有向无环图当且仅当此图不具有点集合数量大于一的强连通分量，因为有向环即是一个强连通分量，而且任何的强连通分量皆具有至少一个有向环。(依然来自Wikipedia) 依旧看不懂对不对？ 那我们给个简明的定义： G'=\{V|V \in G,\forall V_a→V_b\} $G’$ 即为强连通分量 还是看不懂？ 上图 在下面der子图中，每一个点都可以经过某条或某几条边到达其他任意的一个点，所以这个子图是一个强连通分量。而在下面那个图中，不是所有的点都可以去到其他所有的点（实际上，一个都不能）。所以，这个子图就不是一个强连通分量。 又㕛叒叕看不懂？？？ 我说了，还解释了，还看不懂，我还有什么好说的？ 实现思路我们随便找个点向下dfs，如果若干次后又可以回到它，那显而易见的，从该点回到该点的所有的点所构成的图，即为一个强连通分量。 可是我们dfs的时候，只能找到路径，那我们怎么标记它们是一个强连通分量呢？ 我们引入追溯值。 追溯值表示在dfs中，它能访问的所有点中，dfs序最小的那个编号。容易得出，在一个强连通分量中，追溯值都是一样的，所以我们要把追溯值一样的点都标记一下。那我们怎么做到标记呢？我们就要用一个栈。在进入dfs的时候把它压入栈里，当每个可到达的点的追溯值都大于它时，说明它就是一个强连通分量（它自己本身也是一个强连通分量）中的dfs序最小的那个点（也可以理解为最浅的那个点），于是把压在它上面的栈的点都打上标记就好了。 伪代码1234567891011121314151617181920212223242526272829303132333435363738394041algorithm tarjan isinput: 圖 G = (V, E)output: 以所在的強連通分量劃分的頂點集index := 0S := empty // 置堆疊為空for each v in V do if (v.index is undefined) strongconnect(v) end iffunction strongconnect(v) // 將未使用的最小index值作為節點v的index v.index := index v.lowlink := index index := index + 1 S.push(v) // 考慮v的後繼節點 for each (v, w) in E do if (w.index is undefined) then // 後繼節點w未訪問，呼叫遞迴 strongconnect(w) v.lowlink := min(v.lowlink, w.lowlink) else if (w is in S) then // w已在堆疊S中，亦即在當前強連通分量中 v.lowlink := min(v.lowlink, w.index) end if // 若v是根則出堆疊，並求得一個強連通分量 if (v.lowlink = v.index) then start a new strongly connected component repeat w := S.pop() add w to current strongly connected component until (w = v) output the current strongly connected component end ifend function//Wikipedia大法好 C++实现定义一些东西123456789101112131415struct Node&#123; int y,next;&#125;;Node node[M];//邻接数组//dfn dfs序，cntcolor 标记总数的统计，low 追溯值，color 标记，colortot 不同标记int last[N],cntcolor[N],dfn[N],low[N],color[N],tot,colortot,dtot;bool vis[N];stack&lt;int&gt; st;void paint();void tarjan(int x);public: Tarjan(); void insert(int x,int y); int calcAmount(int n); Tarjan代码1234567891011121314151617181920212223242526void Tarjan::tarjan(int x)&#123; dfn[x]=low[x]=++dtot;//记录dfs序；每个点都可视为一个强连通分量，所以low初始化为dfn st.push(x);//压入栈中 vis[x]=true;//标记访问过 for (int i=last[x];i;i=node[i].next)//遍历每个相连的点 &#123; int y=node[i].y; if (!dfn[y])//没有搜索过 &#123; tarjan(y);//向下更新 low[x]=min(low[x],low[y]);//更新low &#125; else if (vis[y])//搜索过 &#123; low[x]=min(low[x],low[y]);//直接用 &#125; &#125; if (dfn[x]==low[x])//搜索完了 &#123; colortot++;//新加标记 while (st.top()!=x) paint();//对于所有在它上面的点标记 paint();//标记它自己 &#125;&#125; 要注意的是，可能会有几个孤立的子图，因此要遍历所有的点，把前面没有搜过的点都丢进去dfs搜一下 那放完整代码吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#define N 1000001#define M 1000001using namespace std;//--------------------------------------------class Tarjan&#123; struct Node &#123; int y,next; &#125;; Node node[M]; int last[N],cntcolor[N],dfn[N],low[N],color[N],tot,colortot,dtot; bool vis[N]; stack&lt;int&gt; st; void paint(); void tarjan(int x); public: Tarjan(); void insert(int x,int y); int calcAmount(int n); &#125;;void Tarjan::paint()&#123; int x=st.top(); st.pop(); vis[x]=false; color[x]=colortot; cntcolor[colortot]++;&#125;void Tarjan::tarjan(int x)&#123; dfn[x]=low[x]=++dtot; st.push(x); vis[x]=true; for (int i=last[x];i;i=node[i].next) &#123; int y=node[i].y; if (!dfn[y]) &#123; tarjan(y); low[x]=min(low[x],low[y]); &#125; else if (vis[y]) &#123; low[x]=min(low[x],low[y]); &#125; &#125; if (dfn[x]==low[x]) &#123; colortot++; while (st.top()!=x) paint(); paint(); &#125;&#125;Tarjan::Tarjan():tot(0),colortot(0),dtot(0)&#123; memset(node,0,sizeof node); memset(last,0,sizeof last); memset(cntcolor,0,sizeof cntcolor); memset(dfn,0,sizeof dfn); memset(low,0,sizeof low); memset(color,0,sizeof color);&#125; void Tarjan::insert(int x,int y)&#123; node[++tot]=&#123;y,last[x]&#125;; last[x]=tot;&#125;int Tarjan::calcAmount(int n)&#123; for (int i=1;i&lt;=n;i++) &#123; if (!dfn[i])//dfn为0，说明没有访问过 tarjan(i); &#125; int ans=0; for (int i=1;i&lt;=colortot;i++) if (cntcolor[i]&gt;1) ans++; return ans;&#125;//--------------------------------------------Tarjan tj;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for (int i=1,x,y;i&lt;=m;i++) cin&gt;&gt;x&gt;&gt;y,tj.insert(x,y); cout&lt;&lt;tj.calcAmount(n); return 0;&#125; 板子洛谷P2863]]></content>
      <tags>
        <tag>图论</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AC自动机]]></title>
    <url>%2Fdetails%2F2018%2F11-24-aca.html</url>
    <content type="text"><![CDATA[用了就能AC？ 简介 在计算机科学中，Aho–Corasick算法是由Alfred V. Aho和Margaret J.Corasick发明的字符串搜索算法，1用于在输入的一串字符串中匹配有限组“字典”中的子串。它与普通字符串匹配的不同点在于同时与所有字典串进行匹配。算法均摊情况下具有近似于线性的时间复杂度，约为字符串的长度加所有匹配的数量。然而由于需要找到所有匹配数，如果每个子串互相匹配（如字典为a，aa，aaa，aaaa，输入的字符串为aaaa），算法的时间复杂度会近似于匹配的二次函数。 该算法主要依靠构造一个有限状态机（类似于在一个trie树中添加失配指针）来实现。这些额外的失配指针允许在查找字符串失败时进行回退（例如设Trie树的单词cat匹配失败，但是在Trie树中存在另一个单词cart，失配指针就会指向前缀ca），转向某前缀的其他分支，免于重复匹配前缀，提高算法效率。 当一个字典串集合是已知的(例如一个计算机病毒库),就可以以离线方式先将自动机求出并储存以供日后使用，在这种情况下，算法的时间复杂度为输入字符串长度和匹配数量之和。 From Here AC自动机，用于多个模式串在一个文本串中的匹配。它基于 $TRIE$ 树，运用了 $KMP$ 的思想，时间复杂度为 O(n * \sum_{i=1}^na_i + k) 其中，$n$ 为文本串的字符个数， $a_i$ 为以文本串的第 $i$ 个字符结尾的模式串的个数， $k$ 为模式串的字符总数。 AC自动机主要由以下三个部分构成：插入模式串（Insert(string s)），构造 $Fail$ 指针（MakeFail()），查询（Query(string s)） 实现定义我们先定义一个类：AC 123456789101112131415161718class AC&#123; const int ROOT;//根节点 struct Node //TRIE的结点 &#123; int alpha[26]; inline int &amp;operator[] (int k); &#125;; Node node[1000000]; int cnt[1000000],fail[1000000],len;//分别是TRIE结点末尾的标记，失配跳转的Fail指针和TRIE的大小 public: AC();//构造函数，只是为了初始化ROOT void Init();//初始化 void Insert(string s);//在TRIE树上插入模式串 void MakeFail();//构造Fail指针 int Query(string s);//查询文本串&#125;; Insert(string s)和 $TRIE$ 的一模一样，重点：一模一样。改都不用改的那种（要是不会可以点我）。 1234567891011void AC::Insert(string s)&#123; int p=ROOT;//设p为根节点 for (int i=0;i!=s.size();i++) &#123; if (node[p][s[i]-'a']==0)//如果没有下一层 node[p][s[i]-'a']=++len;//构造下一层并设置指针 p=node[p][s[i]-'a'];// &#125; cnt[p]++;&#125; MakeFail()重头戏，造 $Fail$ 指针。 设除根节点以外的任意一个结点编号为 $p$ ,储存的符号为 $c$ , 其父节点编号为 $f$ ，则对于一个“结点”，我们有以下两种情况： “有”这个结点，Fail_f = node[Fail_f] -> c （连向下一个最长匹配的串（统计个数）） “无”这个结点，node[p] -> c = node[Fail_f] -> c （继续搞是不会有结果的，那就直接跳吧（跳转）） 至于遍历结点的方法，我们可以采用 $BFS$ 1234567891011121314151617181920212223void AC::MakeFail()&#123; queue&lt;int&gt; que;//构造队列 for (int i=0;i!=26;i++) if (node[ROOT][i]!=0) que.push(node[ROOT][i]);//将每个可作为开头字母的符号的编号入队 while (!que.empty()) &#123; int p=que.front();que.pop();//取出队头 for (int i=0;i!=26;i++) &#123; if (node[p][i]!=0)//“有”这个结点 &#123; fail[node[p][i]]=node[fail[p]][i];//设置当前结点的Fail指针 que.push(node[p][i]);//将该节点入队 &#125; else//“无”这个结点 &#123; node[p][i]=node[fail[p]][i];//路径压缩 &#125; &#125; &#125;&#125; Query(string s)类似于 $TRIE$ 的查询。只不过要跳 $Fail$ 并累加跳到的字符串的个数 123456789101112131415int AC::Query(string s)&#123; int ans=0,p=ROOT; for (int i=0;i!=s.size();i++)//遍历每个字母 &#123; p=node[p][s[i]-'a'];//求出当前字母的编号 for (int k=p;k!=0&amp;&amp;~cnt[k];k=fail[k])//从当前字母的编号一直跳Fail指针 //这里的cnt[k]一定要取反，不能cnt[k]!=0，否则会wa &#123; ans+=cnt[k];//统计字符串个数 cnt[k]=0;//归零 &#125; &#125; return ans;&#125; 完整的代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;using namespace std;//------------------------------------------------class AC&#123; const int ROOT; struct Node &#123; int alpha[26]; inline int &amp;operator[] (int k); &#125;; Node node[1000000]; int cnt[1000000],fail[1000000],len; public: AC(); void Init(); void Insert(string s); void MakeFail(); int Query(string s);&#125;;AC::AC():ROOT(0)&#123; Init();&#125;int&amp; AC::Node::operator[] (int k)&#123; return alpha[k];&#125;void AC::Init()&#123; memset(node,0,sizeof node); memset(cnt,0,sizeof cnt); memset(fail,0,sizeof fail); len=0;&#125;void AC::Insert(string s)&#123; int p=ROOT; for (int i=0;i!=s.size();i++) &#123; if (node[p][s[i]-'a']==0) node[p][s[i]-'a']=++len; p=node[p][s[i]-'a']; &#125; cnt[p]++;&#125;void AC::MakeFail()&#123; queue&lt;int&gt; que; for (int i=0;i!=26;i++) if (node[ROOT][i]!=0) que.push(node[ROOT][i]); while (!que.empty()) &#123; int p=que.front();que.pop(); for (int i=0;i!=26;i++) &#123; if (node[p][i]!=0) &#123; fail[node[p][i]]=node[fail[p]][i]; que.push(node[p][i]); &#125; else &#123; node[p][i]=node[fail[p]][i]; &#125; &#125; &#125;&#125;int AC::Query(string s)&#123; int ans=0,p=ROOT; for (int i=0;i!=s.size();i++) &#123; p=node[p][s[i]-'a']; for (int k=p;k!=0&amp;&amp;cnt[k]!=0;k=fail[k]) &#123; ans+=cnt[k]; cnt[k]=0; &#125; &#125; return ans;&#125;//------------------------------------------------AC ac;int main()&#123; /* //Example in Luogu P3808 int n; cin&gt;&gt;n; for (int i=1;i&lt;=n;i++) &#123; string s; cin&gt;&gt;s; ac.Insert(s); &#125; ac.MakeFail(); string s; cin&gt;&gt;s; cout&lt;&lt;ac.Query(s); */ return 0;&#125; 板子题这里：洛谷 P3808]]></content>
      <tags>
        <tag>高级数据结构</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调队列]]></title>
    <url>%2Fdetails%2F2018%2F09-24-DanDiaoDuiLie.html</url>
    <content type="text"><![CDATA[来看看单调队列 其实是因为没东西讲了 概念按照惯例，先看看百度百科怎么说 维基百科竟然没有这个词条 单调队列，即单调递减或单调递增的队列。使用频率不高，但在有些程序中会有非同寻常的作用。中文名:单调队列外文名 :Monotone queue地 位 :使用频率不高，但偶尔有重要作用作 用 :1D/1D动态规划等。属于 优先队列的一种 其实他的作用是查询连续的k个数据内最大/最小……的一个。所以必然会连接到：1.值；2.插入的第几个。 实现定义以查询连续的k个数据内最大的一个为例子。先来看看定义 1234567891011class MQ&#123; struct Node &#123; int val,i;//val是结点的值，i是该结点的插入的编号。 &#125;; deque&lt;Node&gt; que;//双端队列 public: int ans[Max];//记录答案 void GetMax(int m,int a[],int n);//在这里用m代替k，用n代替一共的个数&#125;; GetMax()首先，我们需要把 k-1 个元素丢进去，并且同时把队尾元素比当前小的清理掉，然后再把当前的结点插入（记得标上序号！！！） 123456for (int i=1;i&lt;m;i++)&#123; while (que.size()&amp;&amp;que.back().val&lt;=a[i])//如果队列不是空的并且队尾元素比当前小 que.pop_back();//弹出队列 que.push_back(Node&#123;a[i],i&#125;);//把自己插入队列&#125; 然后需要一个非常玄学的操作：把剩下的元素丢进去，边丢边把比自己小的队尾元素丢出来，把自己插进队尾，然后把当前编号-k+1 (i-m+1)&gt;当前队头的都丢出来，并且用一个数据记录在下标为当前编号-k+1 (i-m+1)的地方记录下队头的值。 123456789for (int i=m;i&lt;=n;i++)&#123; while (que.size()&amp;&amp;que.back().val&lt;=a[i]) que.pop_back(); que.push_back(Node&#123;a[i],i&#125;); while (que.size()&amp;&amp;que.front().i&lt;i-m+1) que.pop_front(); ans[i-m+1]=que.front().val;&#125; 然后ans里面的就是要求的啦！ 伪代码伪代码表述如下： 12345678910111213Clear(Queue)Clear(Ans)For i=1 To M-1 Do While (Back(Queue).Val&lt;=A[i] &amp;&amp; IsNotEmpty(Queue) PopBack(Queue) PushBack(Queue,No=i,Val=A[i])For i=M To N Do While (Back(Queue).Val&lt;=A[i] &amp;&amp; IsNotEmpty(Queue) PopBack(Queue) PushBack(Queue,No=i,Val=A[i]) While (Back(Queue).No&lt;i-M+1 &amp;&amp; IsNotEmpty(Queue) PopFront(Queue) Ans[i-M+1]=Front(Queue).Val 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;functional&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;stack&gt;#define Max 2100000using namespace std;//-----------------------------------------------class MQ&#123; struct Node &#123; int val,i; &#125;; deque&lt;Node&gt; que; public: int ans[Max]; void GetMax(int m,int a[],int n);&#125;;void MQ::GetMax(int m,int a[],int n)&#123; while (que.size()) que.pop_back(); memset(ans,0,sizeof ans); for (int i=1;i&lt;m;i++) &#123; while (que.size()&amp;&amp;que.back().val&lt;=a[i]) que.pop_back(); que.push_back(Node&#123;a[i],i&#125;); &#125; for (int i=m;i&lt;=n;i++) &#123; while (que.size()&amp;&amp;que.back().val&lt;=a[i]) que.pop_back(); que.push_back(Node&#123;a[i],i&#125;); while (que.size()&amp;&amp;que.front().i&lt;i-m+1) que.pop_front(); ans[i-m+1]=que.front().val; &#125;&#125;//-----------------------------------------------int main()&#123; return 0;&#125; 参考资料&amp;模板题参考资料：https://baike.baidu.com/item/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/4319570?fr=aladdinhttps://jesselrj.coding.me/2018/08/31/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/ 模板题：这里]]></content>
      <tags>
        <tag>高级数据结构</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2Fdetails%2F2018%2F08-31-UnionCheck.html</url>
    <content type="text"><![CDATA[简介并查集是一种高级数据结构。 先来看看维基怎么说： 在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作：Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。Union：将两个子集合并成同一个集合。由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，MakeSet，用于建立单元素集合。有了这些方法，许多经典的划分问题可以被解决。为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，Find(x) 返回 x 所属集合的代表，而 Union 使用两个集合的代表作为参数。时间复杂度:同时使用路径压缩、按秩（rank）合并优化的程序每个操作的平均时间仅为 {\displaystyle O(\alpha (n))}，其中 {\displaystyle \alpha (n)} 是 {\displaystyle n=f(x)=A(x,x)} 的反函数， {\displaystyle A} 是急速增加的阿克曼函数。因为 {\displaystyle \alpha (n)} 是其反函数，故 {\displaystyle \alpha (n)} 在 {\displaystyle n} 十分巨大时还是小于 5。因此，平均运行时间是一个极小的常数。实际上，这是渐近最优算法：Fredman 和 Saks 在 1989 年解释了 {\displaystyle \Omega (\alpha (n))} 的平均时间内可以获得任何并查集。空间复杂度: {\displaystyle O(n)}（n 为元素数量）（传送门） 是不是贼高大上？ 实现Init我们要先把fa数组初始化为下标（假设自己单独为一棵树） 12345void Init()&#123; for (int i=1;i&lt;=n;i++) fa[i]=i;&#125; Add我们对于每对点执行Add操作，建立联系 123456int Add(int x,int y)&#123; int fx=GetRoot(x),fy=GetRoot(y);//得到该树的Root if (fx!=fy)//不同根说明没有在同一课树上 fa[fx]=fy;//合并两棵树&#125; GetRoot对于每个点，我们需要一个GetRoot操作，向上查询得到它的祖宗。 123456int GetRoot(int k)&#123; if (fa[k]!=k)//祖宗是自己的话，说明它是一棵树的root fa[k]=find(fa[k]);//路径合并，记录祖宗 return fa[k];&#125; Check查询两点是否在同一棵树上 1234int Check(int x,int y)&#123; return GetRoot(x)==GetRoot(y);&#125; 就不贴完整的源码了 懒 参考&amp;模板题参考：https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86 （想学习更快的可以去看看） 模板题：here]]></content>
      <tags>
        <tag>高级数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树]]></title>
    <url>%2Fdetails%2F2018%2F08-30-ZuiXiaoShengChengShu.html</url>
    <content type="text"><![CDATA[高产一波 我们来讲讲最小生成树。 什么是最小生成树先了解以下什么是“最小生成树”日常维基 最小生成树是一副连通加权无向图中一棵权值最小的生成树。在一给定的无向图 G = (V, E) 中，(u, v) 代表连接顶点 u 与顶点 v 的边，即 {\displaystyle (u,v)\in E}，而 w(u, v) 代表此边的权重，若存在 T 为 E 的子集，即 {\displaystyle T\subseteq E}且 (V, T) 为树，使得 {\displaystyle w(T)=\sum _{(u,v)\in T}w(u,v)} w(T)=\sum _{(u,v)\in T}w(u,v)的 w(T) 最小，则此 T 为 G 的最小生成树。最小生成树其实是最小权重生成树的简称。一个连通图可能有多个生成树。当图中的边具有权值时，总会有一个生成树的边的权值之和小于或者等于其它生成树的边的权值之和。广义上而言，对于非连通无向图来说，它的每一连通分量同样有最小生成树，它们的并被称为最小生成森林。以有线电视电缆的架设为例，若只能沿着街道布线，则以街道为边，而路口为顶点，其中必然有一最小生成树能使布线成本最低。(来自这里） 看不懂对不对？我也是 但是，要是题目中有诸如“连接”啊之类的，就是它了。 目前我们有两种常用的求解最小生成树的算法：Kruskal和Prim 毕竟其它的我都不会。在稀疏图中，Kruskal占优；而在稠密图之中，Prim占优。所以说，Kruskal一般用于稀疏图，所以用邻接表实现；而Prim常用于稠密图，所以一般采用邻接矩阵实现你偏要用邻接矩阵实现Kruskal用邻接表实现Prim谁也拦不住你 Kruskal我们先来看看Kruskal 抄维基 Kruskal算法是一种用来查找最小生成树的算法，由Joseph Kruskal在1956年发表。用来解决同样问题的还有Prim算法和Boruvka算法等。三种算法都是贪心算法的应用。和Boruvka算法不同的地方是，Kruskal算法在图中存在相同权值的边时也有效。平均时间复杂度为 {\displaystyle \mathrm {O} (|E|\log |V|)}，其中 {\displaystyle E} 和 {\displaystyle V} 分别是图的边集和点集。(传送门) Kruskal算法基于贪心和并查集，并使用它判断是否连接（或者说是否同根）。如果不同根，则加入该节点（我们默认认为它是有序的）。 并查集并查集可以看这里。 贪心Kruskal采用贪心策略，先让边的权值从小到大排序，保证取出来的是当前剩余边的最小值。 具体实现 其实核心代码就这一点点。 1234567891011int ans=0,t=0;for (int i=1;i&lt;=m;i++)&#123; if (find(node[i].x)!=fy=find(node[i].y))//不在同一棵树中，但是它们是连在一起的，就合并两棵树 &#123; fa[fa[fx]]=fa[fy],ans+=node[i].v;//合并，因为已经排好序。当前取出来的一定比其它可行路径短，于是累加它们的权值。 t++; if (t==n-1)//由最小生成树的性质，边数不超过点数-1 break; &#125;&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;functional&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;stack&gt;using namespace std;//---------------------------------------class Kruskal&#123; struct Node &#123; int x,y,v; bool operator&lt;(const Node &amp;x) const &#123; return this-&gt;v&lt;x.v; &#125; &#125;node[1100000]; int n,m,fa[1100000]; void init(); int find(int k); public: void set(int n); void build(int x,int y,int v); int get();&#125;;void Kruskal::set(int n)&#123; this-&gt;n=n;&#125;void Kruskal::init()&#123; for (int i=1;i&lt;=n;i++) fa[i]=i; sort(node+1,node+m+1);&#125;int Kruskal::find(int k)&#123; if (fa[k]!=k) fa[k]=find(fa[k]); return fa[k];&#125;void Kruskal::build(int x,int y,int v)&#123; m++; node[m]=Node&#123;x,y,v&#125;;&#125;int Kruskal::get()&#123; init(); int ans=0,t=0; for (int i=1;i&lt;=m;i++) &#123; if (find(node[i].x)!=fy=find(node[i].y)) &#123; fa[fa[fx]]=fa[fy],ans+=node[i].v; t++; if (t==n-1) break; &#125; &#125; return ans;&#125;//---------------------------------------Kruskal kl;int main()&#123; return 0;&#125; Prim 普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克发现；并在1957年由美国计算机科学家罗伯特·普里姆独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。通过邻接矩阵图表示的简易实现中，找到所有最小权边共需 {\displaystyle O(|V|^{2})} 的运行时间。使用简单的二叉堆与邻接表来表示的话，普里姆算法的运行时间则可缩减为 {\displaystyle O(|E|\log |V|)} ，其中 {\displaystyle |E|} 为连通图的边集大小， {\displaystyle |V|} 为点集大小。如果使用较为复杂的斐波那契堆，则可将运行时间进一步缩短为 {\displaystyle O(|E|+|V|\log |V|)} ，这在连通图足够密集时（当 {\displaystyle |E|} 满足 {\displaystyle \Omega (|V|\log |V|)} 条件时），可较显著地提高运行速度。 但是我不会堆优化 Init12345678910memset(k1,0,sizeof k1);memset(k2,0,sizeof k2);memset(edge,0x7f,sizeof edge);cin&gt;&gt;n&gt;&gt;m;int x,y,c;for (int i=1;i&lt;=m;i++) cin&gt;&gt;x&gt;&gt;y&gt;&gt;c,edge[x][y]=edge[y][x]=min(edge[x][y],c);//读入并储存到邻接矩阵for (int i=1;i&lt;=n;i++) k2[i]=edge[1][i];//记录当前可和1连接的边的权值k1[1]=1;//标记是否走过该点 GetAns重头戏来了。 其实Prim也是基于贪心思想，每次我们需要找到边权最小的边并不断拓展。 1234567891011121314int ans=0,k=1;//ans记录答案，k记录走的次数while (k&lt;n)//同上文t作用一样，由最小生成树的性质，边数不超过点数-1&#123; k++; int minn=1&lt;&lt;26,p=0; for (int i=1;i&lt;=n;i++)//循环查找没有被选中过（拓展过）而且边权最小的边（贪心） if (!k1[i]&amp;&amp;k2[i]&lt;minn) minn=k2[i],p=i; ans+=minn;//累计最小的边权 for (int i=1;i&lt;=n;i++) if (!k1[i]&amp;&amp;k2[i]&gt;edge[p][i])//记录当前最优解的边权 k2[i]=edge[p][i]; k1[p]=1;//记录走过的边&#125; 完整源代码其实也就这么多，都挺简单的才怪 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;map&gt;#define Max 1200using namespace std;class Prim&#123; int edge[Max][Max],n,m,k2[Max]; bool k1[Max]; public: void init(); int GetAns();&#125;;void Prim::init()&#123; memset(k1,0,sizeof k1); memset(k2,0,sizeof k2); memset(edge,0x7f,sizeof edge); cin&gt;&gt;n&gt;&gt;m; int x,y,c; for (int i=1;i&lt;=m;i++) cin&gt;&gt;x&gt;&gt;y&gt;&gt;c,edge[x][y]=edge[y][x]=min(edge[x][y],c); for (int i=1;i&lt;=n;i++) k2[i]=edge[1][i]; k1[1]=1;&#125;int Prim::GetAns()&#123; int ans=0,k=1; while (k&lt;n) &#123; k++; int minn=1&lt;&lt;26,p=0; for (int i=1;i&lt;=n;i++) if (!k1[i]&amp;&amp;k2[i]&lt;minn) minn=k2[i],p=i; ans+=minn; for (int i=1;i&lt;=n;i++) if (!k1[i]&amp;&amp;k2[i]&gt;edge[p][i]) k2[i]=edge[p][i]; k1[p]=1; &#125; return ans;&#125;Prim prim;int main()&#123; prim.init(); cout&lt;&lt;prim.GetAns(); return 0;&#125; 参考资料&amp;模板题参考资料：https://zh.wikipedia.org/wiki/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95https://zh.wikipedia.org/wiki/%E5%85%8B%E9%B2%81%E6%96%AF%E5%85%8B%E5%B0%94%E6%BC%94%E7%AE%97%E6%B3%95https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91 模板题点这里对Prim十分不友好]]></content>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>最小生成树</tag>
        <tag>Kruskal</tag>
        <tag>Prim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源点最短路径(下)]]></title>
    <url>%2Fdetails%2F2018%2F08-30-DanYuanDianZuiDuanLuJingX.html</url>
    <content type="text"><![CDATA[引语之前我们讲过单源点最短路径的上并介绍了一种高效易懂的算法-SPFA。但是，如果是稠密图，该算法的时间复杂度会急剧攀升，达到O(VE)。所以说，在不需要判负环的情况下，我们可以使用一种更加优异的算法-Dijkstra（戴克斯特拉算法） 概念先看看wikipedia是怎么说的。 戴克斯特拉算法（英语：Dijkstra’s algorithm，又译迪杰斯特拉算法）由荷兰计算机科学家艾兹赫尔·戴克斯特拉在1956年提出。戴克斯特拉算法使用了广度优先搜索解决赋权有向图的单源最短路径问题。该算法存在很多变体；戴克斯特拉的原始版本找到两个顶点之间的最短路径，但是更常见的变体固定了一个顶点作为源节点然后找到该顶点到图中所有其它节点的最短路径，产生一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径。该算法的输入包含了一个有权重的有向图 G，以及G中的一个来源顶点 S。我们以 V 表示 G 中所有顶点的集合。每一个图中的边，都是两个顶点所形成的有序元素对。(u, v) 表示从顶点 u 到 v 有路径相连。我们以 E 表示G中所有边的集合，而边的权重则由权重函数 w: E → [0, ∞] 定义。因此，w(u, v) 就是从顶点 u 到顶点 v 的非负权重（weight）。边的权重可以想像成两个顶点之间的距离。任两点间路径的权重，就是该路径上所有边的权重总和。已知 V 中有顶点 s 及 t，Dijkstra 算法可以找到 s 到 t 的最低权重路径(例如，最短路径)。这个算法也可以在一个图中，找到从一个顶点 s 到任何其他顶点的最短路径。最初的戴克斯特拉算法不采用最小优先级队列，时间复杂度是O(|V|^2)(其中|V|为图的顶点个数)。通过斐波那契堆实现的戴克斯特拉算法时间复杂度是O(|E|+|V|log|V|) (其中|E|是边数) （Fredman &amp; Tarjan 1984）。对于不含负权的有向图，这是目前已知的最快的单源最短路径算法。(摘自维基百科，传送门） Dijkstra不知道比SPFA高到哪里去了。 简单地说：Dijkstra采用优先队列/堆优化，每次取出来的边是最短的，大大减少了需要松弛的边的数量。 实现定义其实Dijkstra在表面上和SPFA是差不多的。 12345678910111213141516171819202122class Dijkstra&#123; int last[Max1],len,ans[Max1]; struct Node &#123; int y,d,next; &#125;; struct edge//用于保存优先队列中的边 &#123; int x,d; bool operator&lt; (const edge &amp;k) const &#123;return d&gt;k.d;&#125; &#125;; Node node[Max2]; priority_queue&lt;edge,vector&lt;edge&gt; &gt; que;//优先队列，使每次取出来的边最小。 void Make(int x,int y,int d); void Add(int x,int y,int d); public: void Scan(int n); int Calc(int x,int y);&#125;; 我们来一个个实现。 Make，Add，Scan没什么好讲的，放代码 12345678910111213141516171819202122232425void Dijkstra::Make(int x,int y,int d)&#123; len++; node[len].y=y; node[len].d=d; node[len].next=last[x]; last[x]=len;&#125;void Dijkstra::Add(int x,int y,int d)&#123; Make(x,y,d); Make(y,x,d);&#125;void Dijkstra::Scan(int n)&#123; int x,y,d; len=0; for (int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;d; Add(x,y,d); &#125;&#125; 重点：Calc来来来，划重点要考 看看伪代码（还是来自维基百科） 1234567891011121314function Dijkstra(G, w, s) for each vertex v in V[G] // 初始化 d[v] := infinity // 将各点的已知最短距离先设成无穷大 previous[v] := undefined // 各点的已知最短路径上的前趋都未知 d[s] := 0 //因为出发点到出发点间不需移动任何距离，所以可以直接将s到s的最小距离设为0 S := empty set Q := set of all vertices while Q is not an empty set // Dijkstra算法主体 u := Extract_Min(Q) S.append(u) for each edge outgoing from u as (u,v) if d[v] &gt; d[u] + w(u,v) // 拓展边（u,v）。w(u,v)为从u到v的路径长度。 d[v] := d[u] + w(u,v) // 更新路径长度到更小的那个和值。 previous[v] := u // 纪录前趋顶点 我们先把dist和优先队列初始化 12345memset(ans,0x7f,sizeof ans);//清空ans，全部设为无穷大ans[x]=0;//源点到源点的长度为0while (que.size())//清空que（没有.clear()太不人性化了） que.pop();que.push(edge&#123;x,0&#125;);//加入源点且边权为0 然后求最短路 12345678910111213141516while (que.size())&#123; int kx=que.top().x,ld=que.top().d; que.pop(); if (ld!=ans[kx])//如果入队时的大小不等于现在的大小，说明已经被更新过了，当前的点无法更新。 continue; for (int i=last[kx];i;i=node[i].next)//遍历所有可从该点走到的点 &#123; int ky=node[i].y,kd=node[i].d; if (ans[ky]&gt;ans[kx]+kd)//判断是否更优 &#123; ans[ky]=ans[kx]+kd; que.push(edge&#123;ky,ans[ky]&#125;);//入队，记得带上当前的边权，注意是当前的！ &#125; &#125;&#125; 那么完整的Calc函数已经呼之欲出了 12345678910111213141516171819202122232425int Dijkstra::Calc(int x,int y)&#123; memset(ans,0x7f,sizeof ans); ans[x]=0; while (que.size()) que.pop(); que.push(edge&#123;x,0&#125;); while (que.size()) &#123; int kx=que.top().x,ld=que.top().d; que.pop(); if (ld!=ans[kx]) continue; for (int i=last[kx];i;i=node[i].next) &#123; int ky=node[i].y,kd=node[i].d; if (ans[ky]&gt;ans[kx]+kd) &#123; ans[ky]=ans[kx]+kd; que.push(edge&#123;ky,ans[ky]&#125;); &#125; &#125; &#125; return ans[y]==0x7f7f7f7f?-1:ans[y];&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;iomanip&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#define Max1 3000000#define Max2 3000000using namespace std;//----------------------------class Dijkstra&#123; int last[Max1],len,ans[Max1]; struct Node &#123; int y,d,next; &#125;; struct edge &#123; int x,d; bool operator&lt; (const edge &amp;k) const; &#125;; Node node[Max2]; priority_queue&lt;edge,vector&lt;edge&gt; &gt; que; void Make(int x,int y,int d); void Add(int x,int y,int d); public: void Scan(int n); int Calc(int x,int y);&#125;;bool Dijkstra::edge::operator&lt; (const edge &amp;k) const &#123;return d&gt;k.d;&#125;void Dijkstra::Make(int x,int y,int d)&#123; len++; node[len].y=y; node[len].d=d; node[len].next=last[x]; last[x]=len;&#125;void Dijkstra::Add(int x,int y,int d)&#123; Make(x,y,d); Make(y,x,d);&#125;void Dijkstra::Scan(int n)&#123; int x,y,d; len=0; for (int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;d; Add(x,y,d); &#125;&#125;int Dijkstra::Calc(int x,int y)&#123; memset(ans,0x7f,sizeof ans); ans[x]=0; while (que.size()) que.pop(); que.push(edge&#123;x,0&#125;); while (que.size()) &#123; int kx=que.top().x,ld=que.top().d; que.pop(); if (ld!=ans[kx]) continue; for (int i=last[kx];i;i=node[i].next) &#123; int ky=node[i].y,kd=node[i].d; if (ans[ky]&gt;ans[kx]+kd) &#123; ans[ky]=ans[kx]+kd; que.push(edge&#123;ky,ans[ky]&#125;); &#125; &#125; &#125; return ans[y]==0x7f7f7f7f?-1:ans[y];&#125;//----------------------------Dijkstra dij;int main()&#123; return 0;&#125; 依然很易于背诵 参考资料，模板题参考资料： https://baike.baidu.com/item/SPFA%E7%AE%97%E6%B3%95/8297411?fromtitle=SPFA&amp;fromid=1101824&amp;fr=aladdin https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95 模板题：这里 （要注意这个模板题是单向边的我调了好久）]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路径</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie]]></title>
    <url>%2Fdetails%2F2018%2F08-27-Trie.html</url>
    <content type="text"><![CDATA[今天我们来看下Trie字典树（念作tree/try） 什么是字典树先来看看什么是字典树 在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。Trie这个术语来自于retrieval。根据词源学，trie的发明者Edward Fredkin把它读作/ˈtriː/ “tree”。但是，其他作者把它读作/ˈtraɪ/ “try”。在图示中，键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一个特定的整数。Trie可以看作是一个确定有限状态自动机，尽管边上的符号一般是隐含在分支的顺序中的。键不需要被显式地保存在节点中。图示中标注出完整的，只是为了演示trie的原理。trie中的键通常是字符串，但也可以是其它的结构。trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。比如，bitwise trie中的键是一串位元，可以用于表示整数或者内存地址。（摘自维基百科。传送门） 啰里八说一大堆，总结一下在OI中的用途：以空间换时间，达到优秀的（O(size(str))的时间复杂度来插入和查询字符串其实查什么都是ok的 如何实现定义字典树是一棵树，采用单数组实现时，我们需要以下声明： 123456789class Trie&#123; int tree[Max][27], len, mark[Max]; //tree诉诸用于储存跳转表，len为指向最后一个数组下标的指针，mark标记单词结束 public: void init();//初始化 void add(string s);//插入一个字符串s int query(string s);//查询一个字符串s&#125;; 那我们来一步步实现。 add字典树一般用跳转表实现。我们用一个二维数组，第一维储存序号，第二维储存跳转到的序号 看一下这张图应该理解了吧？ 1234567891011void Trie::add(string s)&#123; int p = 0; for (int i = 0; i != s.size(); i++) &#123; if (!tree[p][s[i] - 'a']) tree[p][s[i] - 'a'] = ++len; p = tree[p][s[i] - 'a']; &#125; mark[p]++;//统计出现次数&amp;记录结尾&#125; query相当于add操作的小改。 我们想一下，在拓展字符串的过程中，怎么样导致当前路径没有当前字符串？很显然，有两个地方. 第一个地方是在添加的过程中。如果跳转表无法跳到下一个跳转表，则没有当前字符串 12if (!tree[p][s[i] - 'a']) return false; 第二是在标记单词尾的mark数组。 12if (!mark[p]) return false; 综上，我们可以得出以下代码： 1234567891011int Trie::query(string s)&#123; int p = 0; for (int i = 0; i != s.size(); i++) &#123; if (!tree[p][s[i] - 'a']) return 0; p = tree[p][s[i] - 'a']; &#125; return mark[p];&#125; 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;iomanip&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#define Max 1000000using namespace std;//---------------------------------------class Trie&#123; int tree[Max][27], len, mark[Max]; public: void init(); void add(string s); int query(string s);&#125;;void Trie::init()&#123; memset(tree, 0, sizeof tree); memset(mark, 0, sizeof mark); len = 0;&#125;void Trie::add(string s)&#123; int p = 0; for (int i = 0; i != s.size(); i++) &#123; if (!tree[p][s[i] - 'a']) tree[p][s[i] - 'a'] = ++len; p = tree[p][s[i] - 'a']; &#125; mark[p]++;&#125;int Trie::query(string s)&#123; int p = 0; for (int i = 0; i != s.size(); i++) &#123; if (!tree[p][s[i] - 'a']) return 0; p = tree[p][s[i] - 'a']; &#125; return mark[p];&#125;//---------------------------------------Trie trie;int main()&#123; return 0;&#125; 是不是很容易背呢？（滑稽） 参考资料&amp;模板题参考资料：https://zh.wikipedia.org/wiki/Trie 模板题：这里]]></content>
      <tags>
        <tag>高级数据结构</tag>
        <tag>Trie字典树</tag>
        <tag>字符串</tag>
        <tag>查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2Fdetails%2F2018%2F08-26-XianDuanShu.html</url>
    <content type="text"><![CDATA[以下权当废话,不要当真！ 以下权当废话,不要当真！ 以下权当废话,不要当真！ 咳咳。来看看线段树。 概念我们先日常地看看什么叫线段树 线段树（英语：Segment tree）是一种二叉树形数据结构，1977年由Jon Louis Bentley发明1，用以储存区间或线段，并且允许快速查询结构内包含某一点的所有区间。 一个包含n个区间的线段树，空间复杂度为 O(nlogn)，查询的时间复杂度则为O(log n+k)，其中k是符合条件的区间数量。 此数据结构亦可推广到高维度。（摘自维基百科，传送门） 简单来说，它是一颗二叉树，基于分治思想，提供符合结合律的操作当然是要你自己写 实现定义我们以查询区间和为例（如果要求区间最值的话要修改lazy_tag云云。为了方便我们把它们封装到一个类里其实介绍懒)，先定义下各种东西。 1234567891011121314151617class ST&#123; struct Node &#123; long long val, tag; &#125; tree[Max];//储存结点 long long ls(long long k);//左子树 long long rs(long long k);//右子树 void PushDown(long long f, long long l, long long r, long long k); void PushUpSum(long long f);//更新结点和 void PushDown(long long f, long long l, long long r);//向下更新结点和，上同 public: void build(long long f, long long a[], long long l, long long r);//建树 long long query(long long f, long long i, long long j, long long l, long long r);//查询 void updata(long long f, long long i, long long j, long long l, long long r, long long val);//修改&#125;; 先说明一下：f-&gt;父节点，i-&gt;当前区间左边界，j-&gt;当前区间右边界，l-&gt;左边界，r-&gt;右边界, val-&gt;值，tag-&gt;lazy_tag。 有几个闭着眼睛都能写出来的函数我先摆出来。 12345long long ST::ls(long long k) &#123; return k &lt;&lt; 1; &#125;//k&lt;&lt;1 == k*2long long ST::rs(long long k) &#123; return k &lt;&lt; 1 | 1; &#125;// k&lt;&lt;1|1 == k*2+1void ST::PushUpSum(long long f) &#123; tree[f].val = tree[ls(f)].val + tree[rs(f)].val; &#125;//由子结点上推父节点值 我们分步讲，先将lazy_tag，而后再讲操作。 常用的操作有三种： 123build()//建树query()//查询区间的值updata()//更新区间 lazy_tag线段树的精华在于lazy_tag，它大幅降低了时间复杂度。我们可以把它更新后先放着完成其他操作而后向下更新。 12345678910111213void ST::PushDown(long long f, long long l, long long r, long long k)&#123; tree[f].val += k * (r - l + 1);//这里相当于k个子结点和，符合加法结合律 tree[f].tag += k;//传递&#125;void ST::PushDown(long long f, long long l, long long r)&#123; long long mid = (l + r) / 2; PushDown(ls(f), l, mid, tree[f].tag);//更新左子树 PushDown(rs(f), mid + 1, r, tree[f].tag);//更新右子树 tree[f].tag = 0;//更新lazy_tag&#125; bulid()因为是树形结构，我们可以自然而然的想到用递归实现，这样会方便许多。 12345678910111213void ST::build(long long f, long long a[], long long l, long long r)&#123; tree[f].tag = 0;//初始化结点 if (l == r)//如果地柜到最后一层则记录并回退 &#123; tree[f].val = a[l]; return; //一定要记得！ &#125; long long mid = (l + r) / 2; build(ls(f), a, l, mid);//左子树 build(rs(f), a, mid + 1, r);//右子树 PushUpSum(f);//由子结点更新父结点，所以一点要放最后&#125; query()查询也是用递归实现。 12345678910111213long long ST::query(long long f, long long i, long long j, long long l, long long r)&#123; if (i &gt;= l &amp;&amp; j &lt;= r)//如果在此区间中 return tree[f].val; PushDown(f, i, j);//更新子结点 long long mid = (i + j) / 2; long long res = 0; if (l &lt;= mid)//如果在左区间中，递归查找左子树 res += query(ls(f), i, mid, l, r); if (r &gt; mid)//如果在右区间中，递归查找右子树 res += query(rs(f), mid + 1, j, l, r); return res;&#125; updata()还剩一个updata，其实和query差不多。 12345678910111213141516void ST::updata(long long f, long long i, long long j, long long l, long long r, long long val)//val是更新的值&#123; if (i &gt;= l &amp;&amp; j &lt;= r)//如果当前区间在需要更新的区间中，更新 &#123; tree[f].val += val * (j - i + 1); tree[f].tag += val; return; &#125; long long mid = (i + j) / 2; PushDown(f, i, j);//更新子结点 if (l &lt;= mid)//如果在左区间中，递归更新左子树 updata(ls(f), i, mid, l, r, val); if (r &gt; mid)//如果在右区间中，递归更新右子树 updata(rs(f), mid + 1, j, l, r, val); PushUpSum(f);//更新父节点&#125; 是不是很难背很简单呢？（不是） 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;iomanip&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#define Max 500000using namespace std;class ST&#123; struct Node &#123; long long val, tag; &#125; tree[Max]; long long ls(long long k); long long rs(long long k); void PushDown(long long f, long long l, long long r, long long k); void PushUpSum(long long f); void PushDown(long long f, long long l, long long r); public: void init(); void build(long long f, long long a[], long long l, long long r); long long query(long long f, long long i, long long j, long long l, long long r); void updata(long long f, long long i, long long j, long long l, long long r, long long val);&#125;;long long ST::ls(long long k) &#123; return k &lt;&lt; 1; &#125;long long ST::rs(long long k) &#123; return k &lt;&lt; 1 | 1; &#125;void ST::PushUpSum(long long f) &#123; tree[f].val = tree[ls(f)].val + tree[rs(f)].val; &#125;void ST::PushDown(long long f, long long l, long long r, long long k)&#123; tree[f].val += k * (r - l + 1); tree[f].tag += k;&#125;void ST::PushDown(long long f, long long l, long long r)&#123; long long mid = (l + r) / 2; PushDown(ls(f), l, mid, tree[f].tag); PushDown(rs(f), mid + 1, r, tree[f].tag); tree[f].tag = 0;&#125;void ST::init()&#123; memset(tree, 0, sizeof tree);&#125;void ST::build(long long f, long long a[], long long l, long long r)&#123; tree[f].tag = 0; if (l == r) &#123; tree[f].val = a[l]; return; // &#125; long long mid = (l + r) / 2; build(ls(f), a, l, mid); build(rs(f), a, mid + 1, r); PushUpSum(f);&#125;long long ST::query(long long f, long long i, long long j, long long l, long long r)&#123; if (i &gt;= l &amp;&amp; j &lt;= r) return tree[f].val; PushDown(f, i, j);// long long mid = (i + j) / 2; long long res = 0; if (l &lt;= mid) res += query(ls(f), i, mid, l, r); if (r &gt; mid) res += query(rs(f), mid + 1, j, l, r); return res;&#125;void ST::updata(long long f, long long i, long long j, long long l, long long r, long long val)//注意i,j和l,r&#123; if (i &gt;= l &amp;&amp; j &lt;= r) &#123; tree[f].val += val * (j - i + 1); tree[f].tag += val; return; &#125; long long mid = (i + j) / 2; PushDown(f, i, j); if (l &lt;= mid) updata(ls(f), i, mid, l, r, val); if (r &gt; mid) updata(rs(f), mid + 1, j, l, r, val); PushUpSum(f);//&#125;ST st;long long a[Max], n, m;int main()&#123; st.init(); cin &gt;&gt; n &gt;&gt; m; for (long long i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; st.build(1, a, 1, n); long long k, x, y, g; for (long long i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; g; switch (g) &#123; case 1: cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; st.updata(1, 1, n, x, y, k); break; case 2: cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; st.query(1, 1, n, x, y) &lt;&lt; endl; break; &#125; &#125; return 0;&#125; 参考资料&amp;模板题参考资料https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%AE%B5%E6%A0%91_(%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2)https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%AE%B5%E6%A8%B9_(%E5%84%B2%E5%AD%98%E5%8D%80%E9%96%93) 模板题这里]]></content>
      <tags>
        <tag>高级数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dinic-当前弧优化 + 网络流算法时间复杂度纵向对比]]></title>
    <url>%2Fdetails%2F2018%2F08-26-DinicDQHYH.html</url>
    <content type="text"><![CDATA[之前的网络流（下）说过，Dinic有一个当前弧优化。那么今天就来说说“当前弧优化”。 怎么搞？当前弧优化也是很简单，只需要改两个地方。 当前因为是“当前”弧优化，所以我们先解决“当前”。 我们需要在统级函数中加上一个循环复制last到另一个数组里（我以head为例） 12345678910111213void NetworkFlows::dinic()&#123; mf=0; int lf=0; while (fdinic()) &#123; for (int i=1;i&lt;=n;i++) head[i]=last[i];//当前弧优化 while (lf=find(s,1&lt;&lt;26)) mf+=lf; &#125; &#125; 弧优化“当前”搞完了，再搞搞剩下的“弧优化”。 我们这个优化需要在深搜中搞。下面看代码注释。 123456789101112131415161718int NetworkFlows::find(int x,int lf)&#123; if (x==t) return lf; int rlf=0; for (int &amp;i=head[x];i;i=node[i].next)//注意&amp;i，这样我们才能改变head。 &#123; int y=node[i].y; if (node[i].v&amp;&amp;dist[y]==dist[x]+1) if (rlf=find(y,min(lf,node[i].v))) &#123; node[i].v-=rlf; node[i^1].v+=rlf; return rlf; &#125; &#125; return 0;&#125; 我们加了之后，我们就能记录优化（具体的只可意会不可言传，要靠理解（笑哭））。 源码好了，就讲这么多，下面是源代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#define Max 1100000using namespace std;class NetworkFlows&#123; struct Node &#123; int y,v,next; &#125;node[Max]; int dist[Max]; int len,last[Max],s,t,n,m,mf,head[Max]; int find(int x,int lf); void build(int x,int y,int v); public: void init(); void dinic(); bool fdinic(); void print();&#125;;void NetworkFlows::build(int x,int y,int v)&#123; len++; node[len].y=y,node[len].v=v,node[len].next=last[x],last[x]=len;&#125;void NetworkFlows::init()&#123; memset(node,0,sizeof node); int x,y,v; len=1; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for (int i=1;i&lt;=m;i++) cin&gt;&gt;x&gt;&gt;y&gt;&gt;v,build(x,y,v),build(y,x,0);&#125;bool NetworkFlows::fdinic()&#123; memset(dist,0x7f,sizeof dist); queue&lt;int&gt; que; que.push(s); dist[s]=0; while (que.size()) &#123; int x=que.front(); que.pop(); for (int i=last[x];i;i=node[i].next) &#123; int y=node[i].y; if (node[i].v&amp;&amp;dist[y]&gt;dist[x]+1) dist[y]=dist[x]+1,que.push(y); &#125; &#125; return dist[t]!=0x7f7f7f7f;&#125;int NetworkFlows::find(int x,int lf)&#123; if (x==t) return lf; int rlf=0; for (int &amp;i=head[x];i;i=node[i].next)//注意&amp;i，以便改变head[x]进行优化，等同于head[k]=i &#123; int y=node[i].y; if (node[i].v&amp;&amp;dist[y]==dist[x]+1) if (rlf=find(y,min(lf,node[i].v))) &#123; node[i].v-=rlf; node[i^1].v+=rlf; return rlf; &#125; &#125; return 0;&#125;void NetworkFlows::print()&#123; cout&lt;&lt;mf&lt;&lt;endl;&#125;void NetworkFlows::dinic()&#123; mf=0; int lf=0; while (fdinic()) &#123; /*for (int i=1;i&lt;=n;i++) head[i]=last[i];//当前弧优化*/ memcpy(head+1,last+1,n*4); while (lf=find(s,1&lt;&lt;26)) mf+=lf; &#125; &#125;NetworkFlows f;int main()&#123; f.init(); f.dinic(); f.print(); return 0;&#125; 效率？这里有两张洛谷模板题的截图，第一张没加优化，第二张加了。 再来一张EK的。 为什么我写的代码时间复杂度这么~~突出~~神奇？]]></content>
      <tags>
        <tag>图论</tag>
        <tag>Dinic</tag>
        <tag>优化</tag>
        <tag>网络流</tag>
        <tag>效率对比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流：进阶篇]]></title>
    <url>%2Fdetails%2F2018%2F08-25-WanLuoLiujj.html</url>
    <content type="text"><![CDATA[惊了，竟然还有下 众说周知，EK算法的效率十分低下 (O(VE^2)),所以说，我们今天来讲讲另一种常用的而其更快的算法:Dinic 概念首先说一下Dinic算法是什么 Dinic算法（又称Dinitz算法）是一个在网络流中计算最大流的强多项式复杂度的算法，设想由以色列（前苏联）的计算机科学家Yefim (Chaim) A. Dinitz在1970年提出。 算法O(V^2E)的时间复杂度类似于Edmonds–Karp算法，其时间复杂度为O(VE^2)，Dinic算法与Edmonds–Karp算法的不同之处在于它每轮算法都选择最短的可行路径进行增广。 Dinic算法中采用高度标号（level graph）以及阻塞流（blocking flow）实现。(摘自维基百科，传送门) 蛤？和EK的时间复杂度类似？那我学了有什么用？ 其实，O(V^2E)的时间复杂度是Dinic的理论时间复杂度上限，在实际中几乎永远都跑不满，几乎只能用O(能过)来称之。所以说Dinic还是十分优益的(何况还有当前弧优化)。 先定义一下各种需要的东西 12345678910111213141516class NetworkFlows&#123; struct Node &#123; int y,v,next; &#125;node[Max]; //储存邻接表 int dist[Max];//储存分层的信息 int len,last[Max],s,t,n,m,mf;//分别是：指向最后一个邻接表的指针，指向最后一个同x（发出点）的指针数组，原点，汇点，点的个数，边的个数，最大流 int find(int x,int lf); void build(int x,int y,int v); public: void init(); void dinic(); bool fdinic(); void print();&#125;; 分层先看看普通的网络流的图长什么样子。 Dinic算法基于“分层图”的思想，那么我们再看看分了一次层的网络流的图长什么样子。 第一幅图是普通的网络流的图，而第二层是分了一次层的图。 我们可以把它想象成立起来的楼，从第0层（源点，以下叫它s）到最后一层（汇点，以下叫它t），每相邻两个楼层有楼梯。而我们的任务是不断把这张分层并且寻找最短的路径。 首先是如何分层的问题。 我们需要不断从s点向外拓展并且标上序号，那么我们应该第一时间可以想到广搜。换一个角度理解，就是把边权都为一的图跑SPFA（当然跑其他的也是ok的）。 12345678910111213141516171819bool NetworkFlows::fdinic()&#123; memset(dist,0x7f,sizeof dist); queue&lt;int&gt; que; dist[s]=0; que.push(s); while (que.size()) &#123; int x=que.front(); que.pop(); for (int i=last[x];i;i=node[i].next) &#123; int y=node[i].y; if (node[i].v&amp;&amp;dist[y]&gt;dist[x]+1)//node[i].v是判断该点是否还有流量可以走 dist[y]=dist[x]+1,que.push(y); &#125; &#125; return dist[t]!=0x7f7f7f7f;&#125; 寻找其次，我们要搞定如何寻找最短路。 我们已经分好层了，所以我们只需要考虑一条路径上的流量是多少，找出来并减掉它。 1234567891011121314151617int NetworkFlows::find(int x,int lf)//x是当前寻找的点，lf是这条路径上的最小流&#123; if (x==t)//如果找到就返回最小流 return lf; int rlf=0; for (int i=last[x];i;i=node[i].next)//寻找其他共x的边 &#123; int y=node[i].y; if (node[i].v&amp;&amp;dist[y]==dist[x]+1) if (rlf=find(y,min(lf,node[i].v)))//寻找下一个可以连接点，传min(lf,node[i].v)是为了让当前是最小的流 &#123; node[i].v-=rlf,node[i^1].v+=rlf;//减掉这条路径的最小流 return rlf; &#125; &#125; return 0;&#125; 统计那么我们怎么统计出来呢？ 我们还需要两层while循环，一层循环fdinic()以不断寻找分层图，一层find(s,1&lt;&gt;)不断去寻找当前分层图的最小流。 12345678void NetworkFlows::dinic()&#123; mf=0; int lowf=0; while (fdinic()) while (lowf=find(s,1&lt;&lt;26)) mf+=lowf;&#125; 源码好了，剩下的包括初始化和输入之类的应该不用讲了。那我们直接放代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#define Max 1100000using namespace std;class NetworkFlows&#123; struct Node &#123; int y,v,next; &#125;node[Max]; int dist[Max]; int len,last[Max],s,t,n,m,mf; int find(int x,int lf); void build(int x,int y,int v); bool fdinic(); public: void init(); void dinic(); void print();&#125;;void NetworkFlows::build(int x,int y,int v)&#123; len++; node[len].y=y,node[len].v=v,node[len].next=last[x],last[x]=len;&#125;void NetworkFlows::init()&#123; memset(node,0,sizeof node); int x,y,v; len=1; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for (int i=1;i&lt;=m;i++) cin&gt;&gt;x&gt;&gt;y&gt;&gt;v,build(x,y,v),build(y,x,0);&#125;bool NetworkFlows::fdinic()&#123; memset(dist,0x7f,sizeof dist); queue&lt;int&gt; que; dist[s]=0; que.push(s); while (que.size()) &#123; int x=que.front(); que.pop(); for (int i=last[x];i;i=node[i].next) &#123; int y=node[i].y; if (node[i].v&amp;&amp;dist[y]&gt;dist[x]+1) dist[y]=dist[x]+1,que.push(y); &#125; &#125; return dist[t]!=0x7f7f7f7f;&#125;int NetworkFlows::find(int x,int lf)&#123; if (x==t) return lf; int rlf=0; for (int i=last[x];i;i=node[i].next) &#123; int y=node[i].y; if (node[i].v&amp;&amp;dist[y]==dist[x]+1) if (rlf=find(y,min(lf,node[i].v))) &#123; node[i].v-=rlf,node[i^1].v+=rlf; return rlf; &#125; &#125; return 0;&#125;void NetworkFlows::print()&#123; cout&lt;&lt;mf&lt;&lt;endl;&#125;void NetworkFlows::dinic()&#123; mf=0; int lowf=0; while (fdinic()) while (lowf=find(s,1&lt;&lt;26)) mf+=lowf;&#125;NetworkFlows f;int main()&#123; f.init(); f.dinic(); f.print(); return 0;&#125; 参考资料&amp;模板题https://zh.wikipedia.org/wiki/Dinic%E7%AE%97%E6%B3%95 模板题点这里]]></content>
      <tags>
        <tag>图论</tag>
        <tag>Dinic</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆]]></title>
    <url>%2Fdetails%2F2018%2F08-25-Heap.html</url>
    <content type="text"><![CDATA[好，今天来讲堆。 priority_queue先讲一个十分偷懒的方法：STL中的容器：priority_queue（优先队列） 首先要先包含库,priority_queue包含于queue中： 1#include&lt;queue&gt; 先声明 12template &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue; 什么？看不懂？这里有一个简单版的~~ 1priority_queue&lt;typename/*你要定义的类型名*/,vector&lt;typename/*同上*/&gt; q; 默认是小根堆，如果想要大根堆怎么办?那就改成： 1priority_queue&lt;typename/*你要定义的类型名*/,vector&lt;typename/*同上*/,greater&lt;typename/*依然同上*/&gt; &gt; q; 啥？你自己写的结构体/类？那就重载&lt;号就行了！ 还有几个比较常用的操作： 1234q.push(x)//把x放入队中q.pop()//把队头删除出x=q.top()//取出队头的值（不会删掉）l=q.size()//获得队列中元素数量 堆好，讲正事：堆咋搞？ 概念我们以小根堆为例，首先要知道的是，堆是一棵完全二叉树，像这样 可以看出规律： A[i]&lt;=A[i2], A[i]&lt;=A[i2+1] 堆基本支持以下几种操作（其实我合并了一下，想了解完整的点这里： 123push(k)pop()top() 实现首先，我们先把该定义的给它定义了： 1int tree[1000000],len;//heap数组作为储存树用，len则指向最后一个元素 然后我们一个个实现这些操作。 push(k)我们先把k放入堆尾，不管它有没有序 1heap[++len]=k; 然后我们需要一些操作来维持它的性质。定义指针now和next分别指向堆尾和堆尾的父节点，也就是now/2 1int now=len,next=now/2; 然后呢，我们用一个while循环直到now到顶（==1）或者我们在中途打断它为止。 12345678while (now)&#123; if (tree[now] &lt; tree[next])//判断是否符合性质 swap(tree[now], tree[next]); else break;//如果没有交换，根据性质，该堆已经符合了性质，就可以退了 now = next, next = now / 2;//寻找下一个结点和其父节点&#125; push(k)就完成了。 pop()先把堆顶结点删掉。这个就有很多办法了。我选择把堆顶和堆尾交换然后len—。 12swap(tree[1], tree[len]);len--; 然后依然建立指针now和next，不过这次的now指向堆顶，next指向他的左子结点。 1int now = 1, next = now * 2; 还是使用while循环。 12345678910while (next &lt;= len)&#123; if (next &lt; len &amp;&amp; tree[next] &gt; tree[next + 1])//找出较小的子结点 next++; if (tree[now] &gt; tree[next])//注意大于号和小于号，push是从下至上而pop是从上至下所以应该反过来。 swap(tree[now], tree[next]); else//同上 break; now = next, next = now * 2;&#125; top()这个没什么好讲，直接把堆顶拿了就是了。 1return tree[1]; 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;iomanip&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;map&gt;#define Max 1100000using namespace std;//----------------------------class Heap&#123; int tree[Max]; int len; public: int push(int k); int pop(); int top(); void clear(); int size();&#125;;int Heap::push(int k)&#123; tree[++len] = k; int now = len, next = len / 2; while (now) &#123; if (tree[now] &lt; tree[next]) swap(tree[now], tree[next]); else break; now = next, next = now / 2; &#125; return k;&#125;int Heap::pop()&#123; swap(tree[1], tree[len]); len--; int now = 1, next = now * 2; while (next &lt;= len) &#123; if (next &lt; len &amp;&amp; tree[next] &gt; tree[next + 1]) next++; if (tree[now] &gt; tree[next]) swap(tree[now], tree[next]); else break; now = next, next = now * 2; &#125; return tree[len + 1];&#125;int Heap::top()&#123; return tree[1];&#125;void Heap::clear()&#123; memset(tree, 0, sizeof tree); len = 0;&#125;int Heap::size()&#123; return len;&#125;//----------------------------Heap heap;int main()&#123; return 0;&#125; 参考资料&amp;模板题https://zh.wikipedia.org/wiki/%E5%A0%86_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84) https://baike.baidu.com/item/最小堆/9139372?fromtitle=小根堆&amp;fromid=4633461&amp;fr=aladdin 模板题点这里]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>堆</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源点最短路径(上)]]></title>
    <url>%2Fdetails%2F2018%2F08-22-DanYuanDianZuiDuanLuJIng.html</url>
    <content type="text"><![CDATA[依然很可能没有下 最短路径？科科。说到最短路径，那么首先，最短路径是什么呢？很明显，是一个点到另一个点可行路径的最小权值和（废话） 上一幅图 我们设s=1，t=8，求的就是s~t中可行路径的权值和（要注意，边是双向的） 当然，最简单的办法是直接建立邻接矩阵，然后循环每个可行路径，最后找到最短路径。这就是Floyd算法。因为每个边都要拓展一次，所以说其时间复杂度是很大的（O(n^3)）。 邻接表所以说，我们这时应该换下思路。在Floyd中，我们使用“点”为标志存储，那我们可不可以使用“边”为标志存储呢？当然可以！邻接图！ 在下文中，我们把边的起点，终点和权值分别叫做x，y和d。我们使用一个结构体来储存边的y,d和上一条同x的边。 1234struct Node&#123; int y,d,next;&#125;node[1000000]; 为了储存上一条同x点边的下标，我们还需要一个数组last。同时，我们还需要一个变量len来储存当前边的下标以及一个数组ans来储存s-&gt;当前点的答案。 1int len,last[1000000],ans[1000000]; SPFA好，万事俱备。那么怎么求出最短路呢?先讲一个初级的算法：SPFA (shortest path faster algorithm)。这是Bellman-Ford算法的队列优化，SPFA只在中国大陆通用。发明者是个国人，这是论文。 队列优化是什么？当然是广度优先搜索啦！ 我们先将s点入队，并建立一个标记，然后进入一个循环，不断从队列中取出队头并拓展（专业点叫做“松弛”）。问题来了，怎么不断找到同端点的点呢？其实很简单，只需要一个循环就可以了。我们先从last数组中取出最后的一条边，再不断通过当前边的next找下一条边就可以了。 1234for (int i=last[kx];i;i=node[kx].next)//我们把队头的点叫做kx&#123; //.......&#125; 我们再把当前边的y叫做ky，把当前边的d叫做kd。如果ans[ky]&gt;ans[kx]+kd，那么就说明走这条边可能得到最优解，所以我们更新ans[ky]的值并判断有没有打上标记，没有的话，说明没有入队，那我们就把他入队。记得在循环的后面要把那个标记抹掉。 12345678910111213for (int i=last[kx];i;i=node[i].next)&#123; int ky=node[i].y; if (ans[ky]&gt;ans[kx]+node[i].d) &#123; ans[ky]=ans[kx]+node[i].d; if (!pd.count(ky)) &#123; pd.insert(ky); que.push(ky); &#125; &#125;&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;queue&gt;#define Max1 1000000#define Max2 1000000#define Max3 Max1using namespace std;//----------------------------class SPFA&#123; class Pc &#123; bool ps[Max3]; public: bool count(int k); void insert(int k); void clear(); bool erase(int k); &#125;; struct Node &#123; int x,y,d,next; &#125;; Node node[Max1]; int last[Max2],len,ans[Max1]; Pc pd; queue&lt;int&gt; que; void MakeLine(int x,int y,int d); public: void scan(int n); int calc(int x,int y);&#125;;bool SPFA::Pc::count(int k)&#123;return (ps[k]);&#125;void SPFA::Pc::insert(int k)&#123;ps[k]=1;&#125;void SPFA::Pc::clear()&#123;memset(ps,0,sizeof ps);&#125;bool SPFA::Pc::erase(int k)&#123;ps[k]=0;&#125;void SPFA::MakeLine(int x,int y,int d)&#123; len++; node[len].x=x,node[len].y=y,node[len].d=d,node[len].next=last[x]; last[x]=len;&#125;int SPFA::calc(int x,int y)&#123; memset(ans,0x7f,sizeof ans); ans[x]=0; while (que.size()) que.pop(); pd.clear(); que.push(x); pd.insert(x); while (!que.empty()) &#123; int kx=que.front(); que.pop(); pd.erase(kx); for (int i=last[kx];i;i=node[i].next) &#123; int ky=node[i].y; if (ans[ky]&gt;ans[kx]+node[i].d) &#123; ans[ky]=ans[kx]+node[i].d; if (!pd.count(ky)) &#123; pd.insert(ky); que.push(ky); &#125; &#125; &#125; &#125; return ans[y]==0x7f7f7f7f?-1:ans[y];&#125;void SPFA::scan(int n)&#123; int x,y,v; for (int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;v; MakeLine(x,y,v); MakeLine(y,x,v); &#125;&#125;//----------------------------SPFA spfa;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; spfa.scan(m); cout&lt;&lt;spfa.calc(1,n); return 0;&#125; 时间复杂度这个算法时间复杂度虽然还ok，但是稠密图是会下降为O(VE)。 话说平均复杂度竟然是通过实验得出的，太不靠谱了吧？ 参考资料https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%BF%AB%E9%80%9F%E7%AE%97%E6%B3%95 https://baike.baidu.com/item/SPFA%E7%AE%97%E6%B3%95/8297411?fromtitle=SPFA&amp;fromid=11018124&amp;fr=aladdin]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路径</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流：入门篇]]></title>
    <url>%2Fdetails%2F2018%2F08-04-WanLuoLiurm.html</url>
    <content type="text"><![CDATA[（也不知道会不会有进阶篇） Part1 最大流什么叫网络流 okok，我们先来讲一下什么叫网络流 这里有一幅图 每一个边都有一个流量，我们叫它V 把它想象成一个自来水厂和你家之间的供水线路，有一个原点s(自来水厂)和一个汇点t(你家)。问你家在一个单位时间内最大可以有多少水用。 很明显，水的多少取决于最小的边的流量。在这张图中，你家最多可以有7+4=13的水。 那么算法的关键就是如何找出最小的边并拓展。 EK 祭出大法：EK(Edmonds-Karp)算法！ 先看下定义。 定义&amp;实现1234567891011121314struct Node&#123; int y,v,next;&#125;node[Max];//记录边，y为尾，v为该边流量，next为下一条同首的边struct prev&#123; int x,i; &#125;pre[Max];//记录当前增广路的边，x为首，i为尾。bool pd[Max];//判断是否在队中int len,last[Max],s,t,n,m;//len是用于记录边的，last当前是以x为首的最后一条边。bool find();//寻找增广路void build(int x,int y,int v);//建边void init();//初始化int EK();//循环计数 该算法使用一个张扬而不做作的广搜，拓展所有以que.front()为开头的边(初始化时，s入队)，当判断它没有被记录时，记录。当当前拓展的边就是t时,返回1。当队列为空时，说明所有的边以及拓展完毕，没有找到t，就是没有从s-&gt;t的边，返回0； 123456789101112131415161718192021222324memset(pd,0,sizeof pd);memset(pre,0,sizeof pre);queue&lt;int&gt; que;que.push(s);pd[s]=1;while (!que.empty())&#123; int x=que.front(); que.pop(); for (int i=last[x];i;i=node[i].next)//寻找以x为首的边（或者说x可以拓展的边） &#123; int y=node[i].y; if (!pd[y]&amp;&amp;node[i].v)//如果当前边没有被记录过并且还有空间可以流水 &#123; pd[y]=1;//打上标记，表示被记录 pre[y].x=x;//记录边 pre[y].i=i;//同上 que.push(y);//入队 if (y==t) return 1; &#125; &#125; return 0;&#125; 再使用一个低调奢华有内涵的循环。当当前还存在增广路的话，循环遍历寻找增广路上最小的值，再循环遍历剪掉。此时，最大流加上当前的最小的值。 当广搜返回0时，说明没有增广路了，当前已累计最大流。 1234567891011int ans=0;while (find())&#123; int minn=1&lt;&lt;26; for (int i=t;i!=s;i=pre[i].x) minn=min(minn,node[pre[i].i].v); for (int i=t;i!=s;i=pre[i].x) node[pre[i].i].v-=minn,node[pre[i].i^1].v+=minn;//要注意，len要从一个奇数开始，这样把当前的编号^1就是其反向边的编号;我喜欢用1.你用其他的话你自己修改。 ans+=minn;&#125;return ans; 完整源码什么？你想要完整版？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#define Max 1100000using namespace std;class NetworkFlows&#123; struct Node &#123; int y,v,next; &#125;node[Max]; struct prev &#123; int x,i; &#125;pre[Max]; bool pd[Max]; int len,last[Max],s,t,n,m; bool find(); void build(int x,int y,int v); public: void init(); int EK();&#125;;void NetworkFlows::build(int x,int y,int v)&#123; len++; node[len].y=y,node[len].v=v,node[len].next=last[x],last[x]=len;&#125;void NetworkFlows::init()&#123; memset(node,0,sizeof node); int x,y,d; len=1; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for (int i=1;i&lt;=m;i++) cin&gt;&gt;x&gt;&gt;y&gt;&gt;d,build(x,y,d),build(y,x,0);&#125;bool NetworkFlows::find()&#123; memset(pd,0,sizeof pd); memset(pre,0,sizeof pre); queue&lt;int&gt; que; que.push(s); pd[s]=1; while (!que.empty()) &#123; int x=que.front(); que.pop(); for (int i=last[x];i;i=node[i].next) &#123; int y=node[i].y; if (!pd[y]&amp;&amp;node[i].v) &#123; pd[y]=1; pre[y].x=x; pre[y].i=i; que.push(y); if (y==t) return 1; &#125; &#125; &#125; return 0;&#125;int NetworkFlows::EK()&#123; int ans=0; while (find()) &#123; int minn=1&lt;&lt;26; for (int i=t;i!=s;i=pre[i].x) minn=min(minn,node[pre[i].i].v); for (int i=t;i!=s;i=pre[i].x) node[pre[i].i].v-=minn,node[pre[i].i^1].v+=minn; ans+=minn; &#125; return ans;&#125;NetworkFlows f;int main()&#123; f.init(); cout&lt;&lt;f.EK()&lt;&lt;endl; return 0;&#125; 注意咯！需要特别注意的是，要加上反向边！！！拓展到反向边时，要加上当前最小的值你问我为什么？我怎么知道！ (╯≥▽≤)╯~ ┴—┴ 咳咳，其实这样才可以有后悔的机会嘛。 Part2 最小费用最大流什么是“最小费用”先看一下最小费用是啥 我们在流量v的基础上又加了一个花费w，我们要求的是最大流中的最小花费 说到最小费用先想到什么呢？最短路！所以我们可以用一个最短路算法（也就是说把原来的广搜换成最短路并记录路径）（我喜欢用spfa毕竟我不会其他的）来求出一条s-&gt;t花费最小的边并累加费用和流量就ok了！ 要注意，我们要在加反向边且v为0的基础上，同时设反向边的w为-w，这样我们便有后悔的机会。 源码放出代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#define Max 1100000using namespace std;class NetworkFlows&#123; struct Node &#123; int y,v,w,next; &#125;node[Max]; struct prev &#123; int x,i; &#125;pre[Max]; bool pd[Max]; int spfa[Max]; int len,last[Max],s,t,n,m,mf,co;//co是花费 bool find(); void build(int x,int y,int v,int w); public: void init(); void EK(); void print();&#125;;void NetworkFlows::build(int x,int y,int v,int w)&#123; len++; node[len].y=y,node[len].v=v,node[len].w=w,node[len].next=last[x],last[x]=len;&#125;void NetworkFlows::init()&#123; memset(node,0,sizeof node); int x,y,v,w; len=1; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; for (int i=1;i&lt;=m;i++) cin&gt;&gt;x&gt;&gt;y&gt;&gt;v&gt;&gt;w,build(x,y,v,w),build(y,x,0,-w);&#125;bool NetworkFlows::find()//spfa求最短路&#123; memset(pd,0,sizeof pd); memset(pre,0,sizeof pre); memset(spfa,0x3f,sizeof spfa); queue&lt;int&gt; que; que.push(s); pd[s]=1; spfa[s]=0; while (!que.empty()) &#123; int x=que.front(); que.pop(); pd[x]=0; for (int i=last[x];i;i=node[i].next) &#123; int y=node[i].y; if (spfa[y]&gt;spfa[x]+node[i].w&amp;&amp;node[i].v) &#123; spfa[y]=spfa[x]+node[i].w; pre[y].i=i,pre[y].x=x; if (!pd[y]) pd[y]=1,que.push(y); &#125; &#125; &#125; return spfa[t]!=0x3f3f3f3f;//是否有s-&gt;t的路径&#125;void NetworkFlows::print()&#123; cout&lt;&lt;mf&lt;&lt;' '&lt;&lt;co&lt;&lt;endl;&#125;void NetworkFlows::EK()&#123; mf=0,co=0; while (find()) &#123; int minn=1&lt;&lt;26; for (int i=t;i!=s;i=pre[i].x) minn=min(minn,node[pre[i].i].v); for (int i=t;i!=s;i=pre[i].x) node[pre[i].i].v-=minn,node[pre[i].i^1].v+=minn; mf+=minn; co+=minn*spfa[t]; &#125;&#125;NetworkFlows f;int main()&#123; f.init(); f.EK(); f.print(); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>EK</tag>
      </tags>
  </entry>
</search>
